Index: Server/src/main/java/com/server/server/utils/handleStrategies/DeleteStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.utils.handleStrategies;\n\nimport com.server.server.models.Logger;\nimport com.server.server.models.Packet;\nimport com.server.server.utils.PacketHandlerStrategy;\nimport com.server.server.utils.PacketUtils;\nimport com.server.server.utils.specificHandlers.DeleteHandler;\n\nimport java.io.ObjectOutputStream;\n\npublic class DeleteStrategy implements PacketHandlerStrategy {\n    @Override\n    public void handlePacket(Packet packet, ObjectOutputStream objectOutputStream, Logger logger) {\n        Packet responsePacket;\n        if(packet.getPayload() instanceof Integer id){\n            logger.log(\"Received delete request from : \" + packet.getSender(), \"Delete\" );\n            DeleteHandler deleteHandler = new DeleteHandler();\n            responsePacket = deleteHandler.delete(id, packet.getSender());\n        } else {\n            logger.log(\"Received delete request with invalid Payload type : \" + packet.getPayload().getClass(), \"Error\" );\n            return;\n        }\n\n        if(responsePacket.getOperation().equals(\"successful\")){\n            logger.log(\"Deleted email : \" + id + \" of user : \" + packet.getSender(), \"Delete\" );\n        } else {\n            logger.log(\"Failed to delete email : \" + id + \" of user : \" + packet.getSender(), \"Error\" );\n        }\n        PacketUtils.sendPacket(responsePacket, objectOutputStream);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/utils/handleStrategies/DeleteStrategy.java b/Server/src/main/java/com/server/server/utils/handleStrategies/DeleteStrategy.java
--- a/Server/src/main/java/com/server/server/utils/handleStrategies/DeleteStrategy.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/utils/handleStrategies/DeleteStrategy.java	(date 1702256904434)
@@ -8,7 +8,21 @@
 
 import java.io.ObjectOutputStream;
 
+/**
+ * This class implements the PacketHandlerStrategy interface and provides a specific strategy to handle delete packets.
+ */
 public class DeleteStrategy implements PacketHandlerStrategy {
+
+    /**
+     * This method handles the incoming packet and performs the necessary operations based on the packet's payload.
+     * If the payload is an integer, it logs the delete request, creates a new DeleteHandler, and calls its delete method.
+     * If the payload is not an integer, it logs an error message and returns without doing anything.
+     * After handling the packet, it sends a response packet back to the sender.
+     *
+     * @param packet The incoming packet to be handled.
+     * @param objectOutputStream The ObjectOutputStream to send the response packet.
+     * @param logger The logger to log the operations.
+     */
     @Override
     public void handlePacket(Packet packet, ObjectOutputStream objectOutputStream, Logger logger) {
         Packet responsePacket;
@@ -20,7 +34,6 @@
             logger.log("Received delete request with invalid Payload type : " + packet.getPayload().getClass(), "Error" );
             return;
         }
-
         if(responsePacket.getOperation().equals("successful")){
             logger.log("Deleted email : " + id + " of user : " + packet.getSender(), "Delete" );
         } else {
@@ -28,4 +41,4 @@
         }
         PacketUtils.sendPacket(responsePacket, objectOutputStream);
     }
-}
+}
\ No newline at end of file
Index: Server/src/main/java/com/server/server/utils/handleStrategies/EmailStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.utils.handleStrategies;\n\nimport com.server.server.models.Email;\nimport com.server.server.models.Packet;\nimport com.server.server.utils.specificHandlers.EmailHandler;\nimport com.server.server.utils.PacketHandlerStrategy;\nimport com.server.server.utils.PacketUtils;\nimport com.server.server.models.Logger;\n\nimport java.io.ObjectOutputStream;\n\npublic class EmailStrategy implements PacketHandlerStrategy {\n    @Override\n    public void handlePacket(Packet packet, ObjectOutputStream objectOutputStream, Logger logger) {\n        Packet responsePacket;\n        if(packet.getPayload() instanceof Email mail){\n            logger.log(\"Received email from : \" + mail.getSender(), \"Email\" );\n            EmailHandler emailHandler = new EmailHandler();\n            responsePacket = emailHandler.email(mail, mail.getRecipient());\n        } else {\n            logger.log(\"Received email request with invalid Payload type : \" + packet.getPayload().getClass(), \"Error\" );\n            return;\n        }\n\n        if(responsePacket.getOperation().equals(\"successful\")){\n            PacketUtils.sendPacket(responsePacket, objectOutputStream);\n            logger.log(\"Sent email from : \" + packet.getPayload(), \"Email\" );\n        } else {\n            PacketUtils.sendPacket(responsePacket, objectOutputStream);\n            logger.log(\"Failed to send email from : \" + packet.getPayload(), \"Error\" );\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/utils/handleStrategies/EmailStrategy.java b/Server/src/main/java/com/server/server/utils/handleStrategies/EmailStrategy.java
--- a/Server/src/main/java/com/server/server/utils/handleStrategies/EmailStrategy.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/utils/handleStrategies/EmailStrategy.java	(date 1702256877850)
@@ -9,7 +9,21 @@
 
 import java.io.ObjectOutputStream;
 
+/**
+ * This class implements the PacketHandlerStrategy interface and provides a specific strategy to handle email packets.
+ */
 public class EmailStrategy implements PacketHandlerStrategy {
+
+    /**
+     * This method handles the incoming packet and performs the necessary operations based on the packet's payload.
+     * If the payload is an instance of Email, it logs the email request, creates a new EmailHandler, and calls its email method.
+     * If the payload is not an instance of Email, it logs an error message and returns without doing anything.
+     * After handling the packet, it sends a response packet back to the sender.
+     *
+     * @param packet The incoming packet to be handled.
+     * @param objectOutputStream The ObjectOutputStream to send the response packet.
+     * @param logger The logger to log the operations.
+     */
     @Override
     public void handlePacket(Packet packet, ObjectOutputStream objectOutputStream, Logger logger) {
         Packet responsePacket;
@@ -30,4 +44,4 @@
             logger.log("Failed to send email from : " + packet.getPayload(), "Error" );
         }
     }
-}
+}
\ No newline at end of file
Index: Server/src/main/java/com/server/server/models/Email.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.models;\n\nimport java.io.Serial;\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.List;\n\npublic class Email implements Serializable {\n\n    @Serial\n    private static final long serialVersionUID = 5950169519310163575L;\n    private int id;\n    private String sender;\n    private List<String> recipient;\n    private String text;\n    private String title;\n    private Date date;\n    private boolean isRead;\n\n    // Constructor\n    public Email(String sender, List<String> recipient, String text, String title, Date date, boolean isRead) {\n        this.id = 0;\n        this.sender = sender;\n        this.recipient = recipient;\n        this.text = text;\n        this.title = title;\n        this.date = date;\n        this.isRead = isRead;\n    }\n\n    // Getters and Setters\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getSender() {\n        return sender;\n    }\n\n    public void setSender(String sender) {\n        this.sender = sender;\n    }\n\n    public List<String> getRecipient() {\n        return recipient;\n    }\n\n    public void setRecipients(List<String > recipient) {\n        this.recipient = recipient;\n    }\n\n    public String getText() {\n        return text;\n    }\n\n    public void setText(String text) {\n        this.text = text;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public Date getDate() {\n        return date;\n    }\n\n    public void setDate(Date date) {\n        this.date = date;\n    }\n\n    public boolean isRead() {\n        return isRead;\n    }\n\n    public void setRead(boolean read) {\n        isRead = read;\n    }\n\n    // Methods\n    /**\n     * Checks if the username String has the shape of an email address\n     * @param username the username to be checked\n     * @return true if the username String has the shape of an email address, false otherwise\n     */\n    public static boolean isValidFormat(String username) {\n        //check if the username String has the shape of an email address\n        //match the regex pattern for email addresses :\n        //It allows numeric values from 0 to 9\n        //Both uppercase and lowercase letters from a to z are allowed\n        //Underscore \"_\", hyphen \"-\", and dot \".\" are allowed\n        //Dot isn’t allowed at the start and end of the local part\n        //Consecutive dots aren’t allowed\n        //For the local part, a maximum of 64 characters are allowed\n        return username.matches(\"^(?=.{1,64}@)[A-Za-z0-9_-]+(\\\\\\\\.[A-Za-z0-9_-]+)*@[^-][A-Za-z0-9-]+(\\\\\\\\.[A-Za-z0-9-]+)*(\\\\\\\\.[A-Za-z]{2,})$\");\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/models/Email.java b/Server/src/main/java/com/server/server/models/Email.java
--- a/Server/src/main/java/com/server/server/models/Email.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/models/Email.java	(date 1702255253643)
@@ -100,7 +100,7 @@
         //Dot isn’t allowed at the start and end of the local part
         //Consecutive dots aren’t allowed
         //For the local part, a maximum of 64 characters are allowed
-        return username.matches("^(?=.{1,64}@)[A-Za-z0-9_-]+(\\\\.[A-Za-z0-9_-]+)*@[^-][A-Za-z0-9-]+(\\\\.[A-Za-z0-9-]+)*(\\\\.[A-Za-z]{2,})$");
+        return username.matches("^(?=.{1,64}@)[A-Za-z0-9_-]+(\\.[A-Za-z0-9_-]+)*@[^-][A-Za-z0-9-]+(\\.[A-Za-z0-9-]+)*(\\.[A-Za-z]{2,})$");
     }
 
 }
\ No newline at end of file
Index: Server/src/main/java/com/server/server/models/Logger.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.models;\n\nimport javafx.application.Platform;\nimport javafx.beans.property.SimpleStringProperty;\nimport javafx.beans.property.StringProperty;\n\nimport java.io.*;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Logger {\n    private static Logger instance;\n    private final File logFile;\n    private final StringProperty latestLogEvent = new SimpleStringProperty();\n    private final StringProperty latestLogDate = new SimpleStringProperty();\n    private final StringProperty latestLogType = new SimpleStringProperty();\n    private final AtomicInteger logCounter = new AtomicInteger(0);\n\n    private Logger() {\n        SimpleDateFormat formatter = new SimpleDateFormat(\"dd_MM_yyyy_HH_mm_ss\");\n        String baseDir = System.getProperty(\"user.dir\");\n        String relativePath = \"/Server/src/main/resources/com/server/server/logs/\";\n        File directory = new File(baseDir + relativePath);\n        if (!directory.exists()) {\n            boolean created = directory.mkdirs(); // This will create the directory if it doesn't exist\n            if(created){\n                System.out.println(\"Created directory for logs\");\n            }\n            else{\n                System.err.println(\"Failed to create directory for logs\");\n            }\n        }\n        logFile = new File(directory, \"log_\" + formatter.format(new Date()) + \".csv\");\n    }\n    public static Logger getInstance() {\n        if (instance == null) {\n            instance = new Logger();\n        }\n        return instance;\n    }\n\n    public synchronized void log(String message, String type) {\n        try (FileWriter writer = new FileWriter(logFile, true)) {\n            String stringDate = String.valueOf(new Date());\n            writer.write(message + \", \" + type+ \", \"+ stringDate + logCounter.incrementAndGet() + \"\\n\");\n            writer.flush();\n            writer.close();\n            Platform.runLater(() -> {\n                latestLogEvent.set(null); // Reset the latestLogEvent since there can be duplicates\n                latestLogEvent.set(message);\n                latestLogDate.set(null); // Reset the latestLogDate same reason of latestLogEvent\n                latestLogDate.set(stringDate);\n                latestLogType.set(null); // Reset the latestLogType, same reason of latestLogEvent\n                latestLogType.set(type);\n            });\n        } catch (Exception e) {\n            System.err.println(\"Exception occurred while logging: \" + e.getMessage());\n        }\n    }\n\n    public StringProperty latestLogEventProperty() {\n        return latestLogEvent;\n    }\n\n    public StringProperty latestLogDateProperty() {\n        return latestLogDate;\n    }\n\n    public StringProperty latestLogTypeProperty() {\n        return latestLogType;\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/models/Logger.java b/Server/src/main/java/com/server/server/models/Logger.java
--- a/Server/src/main/java/com/server/server/models/Logger.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/models/Logger.java	(date 1702256018762)
@@ -9,14 +9,22 @@
 import java.util.Date;
 import java.util.concurrent.atomic.AtomicInteger;
 
+/**
+ * Logger class for logging events.
+ * This class is a singleton, meaning only one instance of this class can exist.
+ */
 public class Logger {
-    private static Logger instance;
-    private final File logFile;
-    private final StringProperty latestLogEvent = new SimpleStringProperty();
-    private final StringProperty latestLogDate = new SimpleStringProperty();
-    private final StringProperty latestLogType = new SimpleStringProperty();
-    private final AtomicInteger logCounter = new AtomicInteger(0);
+    private static Logger instance; // Singleton instance
+    private final File logFile; // File where logs are written
+    private final StringProperty latestLogEvent = new SimpleStringProperty(); // Latest log event
+    private final StringProperty latestLogDate = new SimpleStringProperty(); // Date of the latest log event
+    private final StringProperty latestLogType = new SimpleStringProperty(); // Type of the latest log event
+    private final AtomicInteger logCounter = new AtomicInteger(0); // Counter for log events
 
+    /**
+     * Private constructor for Logger class.
+     * Initializes the log file in the specified directory.
+     */
     private Logger() {
         SimpleDateFormat formatter = new SimpleDateFormat("dd_MM_yyyy_HH_mm_ss");
         String baseDir = System.getProperty("user.dir");
@@ -33,6 +41,12 @@
         }
         logFile = new File(directory, "log_" + formatter.format(new Date()) + ".csv");
     }
+
+    /**
+     * Method to get the singleton instance of Logger.
+     * If the instance doesn't exist, it is created.
+     * @return Logger instance
+     */
     public static Logger getInstance() {
         if (instance == null) {
             instance = new Logger();
@@ -40,6 +54,12 @@
         return instance;
     }
 
+    /**
+     * Method to log a message.
+     * The message, its type and the current date are written to the log file.
+     * @param message The message to log
+     * @param type The type of the message
+     */
     public synchronized void log(String message, String type) {
         try (FileWriter writer = new FileWriter(logFile, true)) {
             String stringDate = String.valueOf(new Date());
@@ -59,14 +79,26 @@
         }
     }
 
+    /**
+     * Getter for latestLogEvent property.
+     * @return latestLogEvent property
+     */
     public StringProperty latestLogEventProperty() {
         return latestLogEvent;
     }
 
+    /**
+     * Getter for latestLogDate property.
+     * @return latestLogDate property
+     */
     public StringProperty latestLogDateProperty() {
         return latestLogDate;
     }
 
+    /**
+     * Getter for latestLogType property.
+     * @return latestLogType property
+     */
     public StringProperty latestLogTypeProperty() {
         return latestLogType;
     }
Index: Server/src/main/java/com/server/server/models/ConnectionHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.models;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class ConnectionHandler implements Runnable {\n    private final ServerSocket serverSocket;\n    private final ExecutorService executorService;\n    private volatile boolean running;\n    private final boolean serverEverStarted;\n    private AtomicInteger id;\n    private final File idFile;\n\n    public ConnectionHandler(ServerSocket serverSocket, ExecutorService executorService, boolean serverEverStarted) {\n        this.serverSocket = serverSocket;\n        this.executorService = executorService;\n        this.running = true;\n        this.serverEverStarted = serverEverStarted;\n        String baseDir = System.getProperty(\"user.dir\");\n        String relativePath = \"/Server/src/main/resources/com/server/server/id/\";\n        this.idFile = new File(baseDir + relativePath, \"id.txt\");\n        this.id = retrieveID();\n    }\n\n    @Override\n    public void run() {\n        Logger logger = Logger.getInstance();\n        while (running) {\n            try {\n                Socket socket = serverSocket.accept();\n                logger.log(\"New connection from \" + socket.getInetAddress().getHostAddress(), \"System\");\n                executorService.submit(new PacketHandler(id, socket));\n            } catch (IOException e) {\n                if (running) {\n                    logger.log(\"Error with network connection: \" + e.getMessage(), \"Error\");\n                }\n            }\n        }\n        storeId();\n    }\n\n    public void stop() {\n        this.running = false;\n    }\n\n    private synchronized AtomicInteger retrieveID() {\n        Logger logger = Logger.getInstance();\n        try {\n            if (!idFile.exists() && idFile.createNewFile()) {\n                logger.log(\"Created Mail ID file (default: 0) \", \"System\");\n            }\n            Scanner scanner = new Scanner(idFile);\n            id = new AtomicInteger(scanner.hasNextInt() ? scanner.nextInt() : 0);\n            logger.log(\"Retrieved Mail ID from file (\" + id.get() + \") \", \"System\");\n            scanner.close();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error handling id file\", e);\n        }\n        return id;\n    }\n\n    private synchronized void storeId() {\n        if (!serverEverStarted) {\n            Logger logger = Logger.getInstance();\n            logger.log(\"Closing Application, won't store ID since Server never started \", \"System\");\n            return;\n        }\n        try (PrintWriter writer = new PrintWriter(idFile)) {\n            writer.println(id);\n            writer.flush();\n            writer.close();\n            Logger logger = Logger.getInstance();\n            logger.log(\"Stored Mail ID to file (\" + id.get() + \") \", \"System\");\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Error writing to id file\");\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/models/ConnectionHandler.java b/Server/src/main/java/com/server/server/models/ConnectionHandler.java
--- a/Server/src/main/java/com/server/server/models/ConnectionHandler.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/models/ConnectionHandler.java	(date 1702255625608)
@@ -7,6 +7,10 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.atomic.AtomicInteger;
 
+/**
+ * This class is responsible for handling connections to the server.
+ * It implements Runnable to be able to run in a separate thread.
+ */
 public class ConnectionHandler implements Runnable {
     private final ServerSocket serverSocket;
     private final ExecutorService executorService;
@@ -15,6 +19,12 @@
     private AtomicInteger id;
     private final File idFile;
 
+    /**
+     * Constructor for the ConnectionHandler class.
+     * @param serverSocket The server socket to accept connections on.
+     * @param executorService The executor service to run tasks on.
+     * @param serverEverStarted A flag indicating if the server has ever been started.
+     */
     public ConnectionHandler(ServerSocket serverSocket, ExecutorService executorService, boolean serverEverStarted) {
         this.serverSocket = serverSocket;
         this.executorService = executorService;
@@ -26,6 +36,10 @@
         this.id = retrieveID();
     }
 
+    /**
+     * The run method for the Runnable interface.
+     * Accepts connections and submits them to the executor service for processing.
+     */
     @Override
     public void run() {
         Logger logger = Logger.getInstance();
@@ -43,10 +57,17 @@
         storeId();
     }
 
+    /**
+     * Stops the connection handler from accepting new connections.
+     */
     public void stop() {
         this.running = false;
     }
 
+    /**
+     * Retrieves the ID from a file.
+     * @return The ID as an AtomicInteger.
+     */
     private synchronized AtomicInteger retrieveID() {
         Logger logger = Logger.getInstance();
         try {
@@ -63,6 +84,9 @@
         return id;
     }
 
+    /**
+     * Stores the ID to a file.
+     */
     private synchronized void storeId() {
         if (!serverEverStarted) {
             Logger logger = Logger.getInstance();
Index: Server/src/main/java/com/server/server/models/ServerModel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.models;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ServerModel {\n    private static Logger logger;\n    private boolean serverEverStarted = false;\n    private boolean isOn = false;\n    private ServerSocket serverSocket;\n    private ExecutorService executorService;\n    private ConnectionHandler connectionHandler;\n    private int port;\n\n    public int getPort() {\n        return port;\n    }\n\n    public ServerModel() {\n        logger = Logger.getInstance();\n    }\n\n    public void startServer() {\n        if(!serverEverStarted)\n            serverEverStarted = true;\n\n        if(!isOn) {\n            isOn = true;\n            logger.log(\"Started Server\" , \"System\");\n\n            try {\n                serverSocket = new ServerSocket(8081);\n                port = serverSocket.getLocalPort();\n                executorService = Executors.newFixedThreadPool(10);\n                connectionHandler = new ConnectionHandler(serverSocket, executorService, serverEverStarted);\n                new Thread(connectionHandler).start();\n            } catch (IOException e) {\n                logger.log(\"An error occurred while trying to start the server\", \"Error\");\n            }\n        }\n    }\n\n    public void stopServer() {\n        if(isOn){\n            connectionHandler.stop();\n            try {\n                if (serverSocket != null) {\n                    serverSocket.close();\n                }\n                if (executorService != null) {\n                    executorService.shutdown();\n                }\n            } catch (IOException e) {\n                logger.log(\"An error occurred while trying to stop the server\", \"Error\");\n            }\n            isOn = false;\n            logger.log(\"Stopped Server \", \"System\");\n        }\n    }\n\n    public boolean isOn() {\n        return isOn;\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/models/ServerModel.java b/Server/src/main/java/com/server/server/models/ServerModel.java
--- a/Server/src/main/java/com/server/server/models/ServerModel.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/models/ServerModel.java	(date 1702256155372)
@@ -5,23 +5,40 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
+/**
+ * ServerModel class that represents the server.
+ * It handles the starting and stopping of the server.
+ */
 public class ServerModel {
-    private static Logger logger;
-    private boolean serverEverStarted = false;
-    private boolean isOn = false;
-    private ServerSocket serverSocket;
-    private ExecutorService executorService;
-    private ConnectionHandler connectionHandler;
-    private int port;
+    private static Logger logger; // Logger instance for logging events
+    private boolean serverEverStarted = false; // Flag to check if the server has ever been started
+    private boolean isOn = false; // Flag to check if the server is currently on
+    private ServerSocket serverSocket; // ServerSocket for accepting client connections
+    private ExecutorService executorService; // ExecutorService for managing threads
+    private ConnectionHandler connectionHandler; // ConnectionHandler for handling client connections
+    private int port; // Port number on which the server is running
 
+    /**
+     * Getter for the port number.
+     * @return port number
+     */
     public int getPort() {
         return port;
     }
 
+    /**
+     * Constructor for ServerModel.
+     * Initializes the logger.
+     */
     public ServerModel() {
         logger = Logger.getInstance();
     }
 
+    /**
+     * Method to start the server.
+     * If the server has never been started, it sets serverEverStarted to true.
+     * If the server is not currently on, it starts the server and logs the event.
+     */
     public void startServer() {
         if(!serverEverStarted)
             serverEverStarted = true;
@@ -42,6 +59,10 @@
         }
     }
 
+    /**
+     * Method to stop the server.
+     * If the server is currently on, it stops the server, closes the serverSocket and executorService, and logs the event.
+     */
     public void stopServer() {
         if(isOn){
             connectionHandler.stop();
@@ -60,6 +81,10 @@
         }
     }
 
+    /**
+     * Getter for the isOn flag.
+     * @return true if the server is on, false otherwise
+     */
     public boolean isOn() {
         return isOn;
     }
Index: Server/src/main/java/com/server/server/models/PacketHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.models;\n\nimport com.server.server.utils.*;\nimport com.server.server.utils.handleStrategies.*;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class PacketHandler implements Runnable {\n    private final AtomicInteger id;\n    private final Socket socket;\n    private ObjectOutputStream objectOutputStream;\n    private ObjectInputStream objectInputStream;\n    private final Map<String, PacketHandlerStrategy> strategies;\n\n    public PacketHandler(AtomicInteger id, Socket socket) {\n        this.id = id;\n        this.socket = socket;\n        try {\n            this.objectOutputStream = new ObjectOutputStream(socket.getOutputStream());\n            this.objectInputStream = new ObjectInputStream(socket.getInputStream());\n        } catch (IOException e) {\n            System.err.println(\"Error creating input or output stream: \" + e.getMessage());\n        }\n        this.strategies = new HashMap<>();\n        this.strategies.put(\"register\", new RegisterStrategy());\n        this.strategies.put(\"login\", new LoginStrategy());\n        this.strategies.put(\"mail\", new EmailStrategy());\n        this.strategies.put(\"delete\", new DeleteStrategy());\n        this.strategies.put(\"refresh\", new RefreshStrategy());\n    }\n\n    private void closeConnections() {\n        if (socket != null) {\n            try {\n                objectInputStream.close();\n                objectOutputStream.close();\n                socket.close();\n            } catch (IOException e) {\n                System.err.println(\"Error closing connections: \" + e.getMessage());\n            }\n        }\n    }\n\n    @Override\n    public void run() {\n        Logger logger = Logger.getInstance();\n        try {\n            System.out.println(\"Waiting for packet\");\n            Packet packet = null;\n            //Packet packet = (Packet) objectInputStream.readObject(); //wait for packet\n            Object originalPacket = objectInputStream.readObject();\n            System.out.println(originalPacket.getClass());\n            if(originalPacket instanceof Packet){\n                packet = (Packet) originalPacket;\n            } else{\n                System.err.println(\"look man, it is what it is...\");\n            }\n            System.out.println(\"Received packet\");\n\n            if(!PacketUtils.isValidSender(packet.getSender())){\n                logger.log(\"Received packet with invalid sender: \" + packet.getSender(), \"Error\");\n                Packet responsePacket = new Packet(\"failed\", \"invalid sender\", \"server\");\n                PacketUtils.sendPacket(responsePacket, objectOutputStream);\n                return;\n            }\n\n            PacketHandlerStrategy strategy = strategies.get(packet.getOperation());\n            if (strategy != null) {\n                if(strategy instanceof EmailStrategy){ //introduce id to email\n                    Email email = (Email) packet.getPayload(); //check if payload is email\n                    email.setId(id.getAndIncrement());\n                    packet.setPayload(email);\n                }\n                strategy.handlePacket(packet, objectOutputStream, logger);\n            } else {\n                Packet responsePacket = new Packet(\"failed\", \"unknown packet operation\", \"server\");\n                PacketUtils.sendPacket(responsePacket, objectOutputStream);\n                logger.log(\"Received unknown packet type: \" + packet.getOperation(), \"Error\");\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error reading packet: \" + e);\n        } finally {\n            closeConnections();\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/models/PacketHandler.java b/Server/src/main/java/com/server/server/models/PacketHandler.java
--- a/Server/src/main/java/com/server/server/models/PacketHandler.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/models/PacketHandler.java	(date 1702256115439)
@@ -9,15 +9,26 @@
 import java.net.Socket;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Objects;
 import java.util.concurrent.atomic.AtomicInteger;
 
+/**
+ * Class responsible for handling packets received from clients.
+ * Implements Runnable to be used in a separate thread.
+ */
 public class PacketHandler implements Runnable {
-    private final AtomicInteger id;
-    private final Socket socket;
-    private ObjectOutputStream objectOutputStream;
-    private ObjectInputStream objectInputStream;
-    private final Map<String, PacketHandlerStrategy> strategies;
+    private final AtomicInteger id; // Unique ID for the packet handler
+    private final Socket socket; // Socket for communication with the client
+    private ObjectOutputStream objectOutputStream; // Output stream for sending data to the client
+    private ObjectInputStream objectInputStream; // Input stream for receiving data from the client
+    private final Map<String, PacketHandlerStrategy> strategies; // Map of strategies for handling different packet operations
 
+    /**
+     * Constructor for PacketHandler.
+     * Initializes the input and output streams and the strategies map.
+     * @param id Unique ID for the packet handler
+     * @param socket Socket for communication with the client
+     */
     public PacketHandler(AtomicInteger id, Socket socket) {
         this.id = id;
         this.socket = socket;
@@ -35,6 +46,9 @@
         this.strategies.put("refresh", new RefreshStrategy());
     }
 
+    /**
+     * Closes the input and output streams and the socket.
+     */
     private void closeConnections() {
         if (socket != null) {
             try {
@@ -47,13 +61,16 @@
         }
     }
 
+    /**
+     * Main method for the Runnable.
+     * Waits for a packet, validates it, and handles it using the appropriate strategy.
+     */
     @Override
     public void run() {
         Logger logger = Logger.getInstance();
         try {
             System.out.println("Waiting for packet");
             Packet packet = null;
-            //Packet packet = (Packet) objectInputStream.readObject(); //wait for packet
             Object originalPacket = objectInputStream.readObject();
             System.out.println(originalPacket.getClass());
             if(originalPacket instanceof Packet){
@@ -63,7 +80,7 @@
             }
             System.out.println("Received packet");
 
-            if(!PacketUtils.isValidSender(packet.getSender())){
+            if(!PacketUtils.isValidSender(Objects.requireNonNull(packet).getSender())){
                 logger.log("Received packet with invalid sender: " + packet.getSender(), "Error");
                 Packet responsePacket = new Packet("failed", "invalid sender", "server");
                 PacketUtils.sendPacket(responsePacket, objectOutputStream);
Index: Server/src/main/java/com/server/server/controllers/ServerController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.controllers;\n\nimport com.server.server.ServerApplication;\nimport com.server.server.models.Logger;\nimport com.server.server.models.ServerModel;\nimport javafx.application.Platform;\nimport javafx.collections.FXCollections;\nimport javafx.collections.ObservableList;\nimport javafx.fxml.FXML;\nimport javafx.fxml.Initializable;\nimport javafx.geometry.Orientation;\nimport javafx.scene.Node;\nimport javafx.scene.control.*;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.ImageView;\n\nimport java.net.URL;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.ResourceBundle;\n\npublic class ServerController implements Initializable {\n\n    @FXML\n    private Label connectionLabel = new Label();\n    @FXML\n    private ImageView statusIcon;\n    @FXML\n    private ListView<String> logList;\n    @FXML\n    private ListView<String> dateList; // Assuming you have a ListView for dates\n    @FXML\n    private ListView<String> typeList; // New ListView for log types\n\n    private final ObservableList<String> logItems = FXCollections.observableArrayList();\n    private final ObservableList<String> dateItems = FXCollections.observableArrayList(); // ObservableList for dates\n    private final ObservableList<String> typeItems = FXCollections.observableArrayList(); // ObservableList for log types\n    private static ServerModel server;\n\n    private final Image onIcon = new Image(Objects.requireNonNull(ServerApplication.class.getResource(\"icons/on-button.png\")).toExternalForm());\n    private final Image offIcon = new Image(Objects.requireNonNull(ServerApplication.class.getResource(\"icons/off-button.png\")).toExternalForm());\n\n    private ScrollBar getVerticalScrollbar(ListView<?> listView) {\n        ScrollBar scrollbar = null;\n        for (Node node : listView.lookupAll(\".scroll-bar\")) {\n            if (node instanceof ScrollBar bar) {\n                if (bar.getOrientation().equals(Orientation.VERTICAL)) {\n                    scrollbar = bar;\n                }\n            }\n        }\n        return scrollbar;\n    }\n\n    private void bindScrollBars(ScrollBar sb1, ScrollBar sb2) {\n        sb1.valueProperty().bindBidirectional(sb2.valueProperty());\n    }\n\n    @Override\n    public void initialize(URL url, ResourceBundle resourceBundle) {\n        if (connectionLabel != null) {\n            connectionLabel.setText(\"NOT RUNNING\");\n            statusIcon.setImage(offIcon);\n        }\n        Logger logger = Logger.getInstance();\n\n        logList.setItems(logItems); // Set items for logList\n        dateList.setItems(dateItems); // Set items for dateList\n        typeList.setItems(typeItems); // Set items for typeList\n\n        logger.latestLogEventProperty().addListener((obs, oldLogEvent, newLogEvent) -> {\n            if (newLogEvent != null) {\n                logItems.add(newLogEvent);\n            }\n        });\n\n        // Add listener for latestLogDateProperty\n        logger.latestLogDateProperty().addListener((obs, oldLogDate, newLogDate) -> {\n            if (newLogDate != null) {\n                dateItems.add(newLogDate);\n            }\n        });\n\n        // Add listener for latestLogTypeProperty\n        logger.latestLogTypeProperty().addListener((obs, oldLogType, newLogType) -> {\n            if (newLogType != null) {\n                typeItems.add(newLogType);\n            }\n        });\n\n        //async binding of scrollbars to avoid blocking the UI thread\n        Platform.runLater(() -> {\n            ScrollBar logListScrollBar = getVerticalScrollbar(logList);\n            ScrollBar dateListScrollBar = getVerticalScrollbar(dateList);\n            ScrollBar typeListScrollBar = getVerticalScrollbar(typeList);\n\n            bindScrollBars(logListScrollBar, typeListScrollBar);\n            bindScrollBars(typeListScrollBar, dateListScrollBar);\n            bindScrollBars(dateListScrollBar, logListScrollBar);\n        });\n\n        server = new ServerModel();\n    }\n\n    public void handleCloseRequest(javafx.stage.WindowEvent event) {\n        if (server.isOn()) {\n            Alert alert = new Alert(Alert.AlertType.CONFIRMATION);\n            alert.setTitle(\"Confirmation Dialog\");\n            alert.setHeaderText(\"Server is currently running\");\n            alert.setContentText(\"Are you sure you want to stop the server?\");\n            Optional<ButtonType> result = alert.showAndWait();\n            if (result.isPresent() && result.get() == ButtonType.OK){\n                server.stopServer();\n            } else {\n                event.consume();\n            }\n        } else {\n            server.stopServer();\n        }\n    }\n\n    @FXML\n    protected void onOffButtonClick() {\n        if (server.isOn()) {\n            server.stopServer();\n            connectionLabel.setText(\"NOT RUNNING\");\n            statusIcon.setImage(offIcon);\n        } else {\n            statusIcon.setImage(onIcon);\n            server.startServer();\n            connectionLabel.setText(\"CONNECTED to port : \" + server.getPort());\n        }\n        logList.scrollTo(logList.getItems().size() - 1);\n        dateList.scrollTo(dateList.getItems().size() - 1);\n        typeList.scrollTo(typeList.getItems().size() - 1);\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/controllers/ServerController.java b/Server/src/main/java/com/server/server/controllers/ServerController.java
--- a/Server/src/main/java/com/server/server/controllers/ServerController.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/controllers/ServerController.java	(date 1702256241281)
@@ -19,6 +19,10 @@
 import java.util.Optional;
 import java.util.ResourceBundle;
 
+/**
+ * Controller class for the server.
+ * This class handles the UI interactions for the server.
+ */
 public class ServerController implements Initializable {
 
     @FXML
@@ -28,9 +32,9 @@
     @FXML
     private ListView<String> logList;
     @FXML
-    private ListView<String> dateList; // Assuming you have a ListView for dates
+    private ListView<String> dateList; // ListView for dates
     @FXML
-    private ListView<String> typeList; // New ListView for log types
+    private ListView<String> typeList; // ListView for log types
 
     private final ObservableList<String> logItems = FXCollections.observableArrayList();
     private final ObservableList<String> dateItems = FXCollections.observableArrayList(); // ObservableList for dates
@@ -40,6 +44,11 @@
     private final Image onIcon = new Image(Objects.requireNonNull(ServerApplication.class.getResource("icons/on-button.png")).toExternalForm());
     private final Image offIcon = new Image(Objects.requireNonNull(ServerApplication.class.getResource("icons/off-button.png")).toExternalForm());
 
+    /**
+     * Method to get the vertical scrollbar of a ListView.
+     * @param listView ListView to get the scrollbar from
+     * @return vertical scrollbar of the ListView
+     */
     private ScrollBar getVerticalScrollbar(ListView<?> listView) {
         ScrollBar scrollbar = null;
         for (Node node : listView.lookupAll(".scroll-bar")) {
@@ -52,10 +61,20 @@
         return scrollbar;
     }
 
+    /**
+     * Method to bind two scrollbars together.
+     * @param sb1 first scrollbar
+     * @param sb2 second scrollbar
+     */
     private void bindScrollBars(ScrollBar sb1, ScrollBar sb2) {
         sb1.valueProperty().bindBidirectional(sb2.valueProperty());
     }
 
+    /**
+     * Method called to initialize the controller after its root element has been completely processed.
+     * @param url The location used to resolve relative paths for the root object, or null if the location is not known.
+     * @param resourceBundle The resources used to localize the root object, or null if the root object was not localized.
+     */
     @Override
     public void initialize(URL url, ResourceBundle resourceBundle) {
         if (connectionLabel != null) {
@@ -102,6 +121,10 @@
         server = new ServerModel();
     }
 
+    /**
+     * Method to handle the close request event.
+     * @param event WindowEvent
+     */
     public void handleCloseRequest(javafx.stage.WindowEvent event) {
         if (server.isOn()) {
             Alert alert = new Alert(Alert.AlertType.CONFIRMATION);
@@ -119,6 +142,9 @@
         }
     }
 
+    /**
+     * Method to handle the on/off button click event.
+     */
     @FXML
     protected void onOffButtonClick() {
         if (server.isOn()) {
Index: Server/src/main/java/com/server/server/utils/AccountUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.utils;\n\nimport com.google.gson.Gson;\nimport com.google.gson.reflect.TypeToken;\nimport com.server.server.models.Email;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\n\npublic class AccountUtils {\n\n    public static boolean isAlreadyTaken(String accountFolder){\n        // check if the username String is equal to\n        // the name of a folder in the directory:\n        //  \"Server/src/main/resources/com/server/server/accounts\"\n        // if it is, then the username is already taken\n        return !(new File(accountFolder).exists());\n    }\n\n    public static boolean createAccountFolder(String accountFolder) {\n        File directory = new File(accountFolder);\n        return directory.mkdirs();\n    }\n\n    public static boolean initializeAccountFolder(String accountFolder) {\n        HashMap<Integer, Email> emails = new HashMap<>();\n        Gson gson = new Gson();\n        String json = gson.toJson(emails);\n\n        try (FileWriter file = new FileWriter(accountFolder + \"/emails.json\")) {\n            file.write(json);\n            return true;\n        } catch (IOException e) {\n            System.err.println(\"Error initializing account folder: \" + e.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Checks if the account folder exists\n     * @param accountFolder the path to the account folder\n     * @return true if the account folder does not exist\n     */\n    public static boolean doesAccountExist(String accountFolder){ //TODO invert logic\n        return !new File(accountFolder).exists();\n    }\n\n    public static boolean isAccountInitialized(String accountFolder){\n        // check if the username String is equal to\n        // the name of a folder in the directory:\n        //  \"Server/src/main/resources/com/server/server/accounts\"\n        // if it is, then the username is already taken\n        return new File(accountFolder + \"/emails.json\").exists();\n    }\n\n    public static HashMap<Integer, Email> retrieveEmails(String accountFolder) {\n        String emailFile = accountFolder + \"/emails.json\";\n        HashMap<Integer, Email> emails;\n        Gson gson = new Gson();\n\n        // Step 1: Retrieve the emails.json file from the sender's folder\n        try (FileReader reader = new FileReader(emailFile)) {\n            // Step 2: Convert the JSON back into HashMap<ID, Email>\n            Type type = new TypeToken<HashMap<Integer, Email>>(){}.getType();\n            emails = gson.fromJson(reader, type);\n        } catch (IOException e) {\n            System.err.println(\"Error reading emails.json: \" + e.getMessage());\n            return null;\n        }\n        return emails;\n    }\n\n    public static boolean storeEmails(String accountFolder, HashMap<Integer, Email> emails) {\n        String emailFile = accountFolder + \"/emails.json\";\n        Gson gson = new Gson();\n\n        // Step 1: Convert the HashMap back into JSON\n        String json = gson.toJson(emails);\n\n        // Step 2: Write the JSON back into the emails.json file\n        try (FileWriter writer = new FileWriter(emailFile)) {\n            writer.write(json);\n            return true;\n        } catch (IOException e) {\n            System.err.println(\"Error writing to emails.json: \" + e.getMessage());\n            return false;\n        }\n    }\n\n    public static String getAccountFolder(String username){\n        return \"Server/src/main/resources/com/server/server/accounts/\" + username;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/utils/AccountUtils.java b/Server/src/main/java/com/server/server/utils/AccountUtils.java
--- a/Server/src/main/java/com/server/server/utils/AccountUtils.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/utils/AccountUtils.java	(date 1702255802291)
@@ -11,21 +11,35 @@
 import java.lang.reflect.Type;
 import java.util.HashMap;
 
+/**
+ * Utility class for handling account related operations.
+ */
 public class AccountUtils {
 
+    /**
+     * Checks if the account is already taken.
+     * @param accountFolder the path to the account folder
+     * @return true if the account is already taken
+     */
     public static boolean isAlreadyTaken(String accountFolder){
-        // check if the username String is equal to
-        // the name of a folder in the directory:
-        //  "Server/src/main/resources/com/server/server/accounts"
-        // if it is, then the username is already taken
         return !(new File(accountFolder).exists());
     }
 
+    /**
+     * Creates a new account folder.
+     * @param accountFolder the path to the account folder
+     * @return true if the directory was created successfully
+     */
     public static boolean createAccountFolder(String accountFolder) {
         File directory = new File(accountFolder);
         return directory.mkdirs();
     }
 
+    /**
+     * Initializes a new account folder with an empty emails.json file.
+     * @param accountFolder the path to the account folder
+     * @return true if the initialization was successful
+     */
     public static boolean initializeAccountFolder(String accountFolder) {
         HashMap<Integer, Email> emails = new HashMap<>();
         Gson gson = new Gson();
@@ -41,30 +55,34 @@
     }
 
     /**
-     * Checks if the account folder exists
+     * Checks if the account folder exists.
      * @param accountFolder the path to the account folder
      * @return true if the account folder does not exist
      */
-    public static boolean doesAccountExist(String accountFolder){ //TODO invert logic
+    public static boolean doesAccountExist(String accountFolder){
         return !new File(accountFolder).exists();
     }
 
+    /**
+     * Checks if the account is initialized.
+     * @param accountFolder the path to the account folder
+     * @return true if the account is initialized
+     */
     public static boolean isAccountInitialized(String accountFolder){
-        // check if the username String is equal to
-        // the name of a folder in the directory:
-        //  "Server/src/main/resources/com/server/server/accounts"
-        // if it is, then the username is already taken
         return new File(accountFolder + "/emails.json").exists();
     }
 
+    /**
+     * Retrieves the emails from the account folder.
+     * @param accountFolder the path to the account folder
+     * @return a HashMap of emails
+     */
     public static HashMap<Integer, Email> retrieveEmails(String accountFolder) {
         String emailFile = accountFolder + "/emails.json";
         HashMap<Integer, Email> emails;
         Gson gson = new Gson();
 
-        // Step 1: Retrieve the emails.json file from the sender's folder
         try (FileReader reader = new FileReader(emailFile)) {
-            // Step 2: Convert the JSON back into HashMap<ID, Email>
             Type type = new TypeToken<HashMap<Integer, Email>>(){}.getType();
             emails = gson.fromJson(reader, type);
         } catch (IOException e) {
@@ -74,14 +92,17 @@
         return emails;
     }
 
+    /**
+     * Stores the emails in the account folder.
+     * @param accountFolder the path to the account folder
+     * @param emails the emails to be stored
+     * @return true if the emails were stored successfully
+     */
     public static boolean storeEmails(String accountFolder, HashMap<Integer, Email> emails) {
         String emailFile = accountFolder + "/emails.json";
         Gson gson = new Gson();
-
-        // Step 1: Convert the HashMap back into JSON
         String json = gson.toJson(emails);
 
-        // Step 2: Write the JSON back into the emails.json file
         try (FileWriter writer = new FileWriter(emailFile)) {
             writer.write(json);
             return true;
@@ -91,7 +112,12 @@
         }
     }
 
+    /**
+     * Gets the account folder path.
+     * @param username the username of the account
+     * @return the path to the account folder
+     */
     public static String getAccountFolder(String username){
         return "Server/src/main/resources/com/server/server/accounts/" + username;
     }
-}
+}
\ No newline at end of file
Index: Server/src/main/java/com/server/server/utils/PacketHandlerStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.utils;\n\nimport com.server.server.models.Logger;\nimport com.server.server.models.Packet;\n\nimport java.io.ObjectOutputStream;\n\npublic interface PacketHandlerStrategy {\n    void handlePacket(Packet packet, ObjectOutputStream objectOutputStream, Logger logger);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/utils/PacketHandlerStrategy.java b/Server/src/main/java/com/server/server/utils/PacketHandlerStrategy.java
--- a/Server/src/main/java/com/server/server/utils/PacketHandlerStrategy.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/utils/PacketHandlerStrategy.java	(date 1702256345266)
@@ -5,6 +5,18 @@
 
 import java.io.ObjectOutputStream;
 
+/**
+ * Interface for handling packets.
+ * This interface defines a method for handling packets received from clients.
+ */
 public interface PacketHandlerStrategy {
+
+    /**
+     * Method to handle a packet.
+     * This method should be implemented to handle a packet in a specific way.
+     * @param packet The packet to handle
+     * @param objectOutputStream The ObjectOutputStream to write the response to
+     * @param logger The logger to log events
+     */
     void handlePacket(Packet packet, ObjectOutputStream objectOutputStream, Logger logger);
-}
+}
\ No newline at end of file
Index: Server/src/main/java/com/server/server/utils/PacketUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.utils;\n\nimport com.server.server.models.Packet;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\n\npublic class PacketUtils {\n\n    public static boolean isValidSender(String sender) {\n        if (sender == null || sender.isEmpty()) {\n            return false;\n        }\n        // check if the sender String is equal to\n        // the name of a folder in the directory:\n        //  \"Server/src/main/resources/com/server/server/accounts\"\n        return new File(\"Server/src/main/resources/com/server/server/accounts/\" + sender).exists() || sender.equals(\"client\");\n    }\n\n    public static void sendPacket(Packet packet, ObjectOutputStream objectOutputStream) {\n        try {\n            objectOutputStream.writeObject(packet);\n        } catch (IOException e) {\n            System.err.println(\"Error sending packet to client: \" + e.getMessage());\n        }\n        try {\n            objectOutputStream.flush();\n        } catch (IOException e) {\n            System.err.println(\"Error flushing packet to client: \" + e.getMessage());\n        }\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/utils/PacketUtils.java b/Server/src/main/java/com/server/server/utils/PacketUtils.java
--- a/Server/src/main/java/com/server/server/utils/PacketUtils.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/utils/PacketUtils.java	(date 1702256318034)
@@ -6,8 +6,17 @@
 import java.io.IOException;
 import java.io.ObjectOutputStream;
 
+/**
+ * Utility class for handling packets.
+ */
 public class PacketUtils {
 
+    /**
+     * Method to validate the sender of a packet.
+     * Checks if the sender is not null or empty, and if it corresponds to an existing account.
+     * @param sender The sender to validate
+     * @return true if the sender is valid, false otherwise
+     */
     public static boolean isValidSender(String sender) {
         if (sender == null || sender.isEmpty()) {
             return false;
@@ -18,6 +27,12 @@
         return new File("Server/src/main/resources/com/server/server/accounts/" + sender).exists() || sender.equals("client");
     }
 
+    /**
+     * Method to send a packet to a client.
+     * Writes the packet to the ObjectOutputStream and flushes the stream.
+     * @param packet The packet to send
+     * @param objectOutputStream The ObjectOutputStream to write the packet to
+     */
     public static void sendPacket(Packet packet, ObjectOutputStream objectOutputStream) {
         try {
             objectOutputStream.writeObject(packet);
@@ -31,4 +46,4 @@
         }
     }
 
-}
+}
\ No newline at end of file
Index: Server/pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.example</groupId>\n  <artifactId>Server</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <name>Server</name>\n\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <junit.version>5.9.2</junit.version>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>org.openjfx</groupId>\n      <artifactId>javafx-controls</artifactId>\n      <version>21</version>\n    </dependency>\n    <dependency>\n      <groupId>org.openjfx</groupId>\n      <artifactId>javafx-fxml</artifactId>\n      <version>21</version>\n    </dependency>\n    <dependency>\n      <groupId>org.kordamp.bootstrapfx</groupId>\n      <artifactId>bootstrapfx-core</artifactId>\n      <version>0.4.0</version>\n    </dependency>\n    <dependency>\n      <groupId>com.google.code.gson</groupId>\n      <artifactId>gson</artifactId>\n      <version>2.8.9</version>\n    </dependency>\n    <dependency>\n      <groupId>org.junit.jupiter</groupId>\n      <artifactId>junit-jupiter-api</artifactId>\n      <version>${junit.version}</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.junit.jupiter</groupId>\n      <artifactId>junit-jupiter-engine</artifactId>\n      <version>${junit.version}</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <version>3.11.0</version>\n        <configuration>\n          <source>18</source>\n          <target>18</target>\n        </configuration>\n      </plugin>\n      <plugin>\n        <groupId>org.openjfx</groupId>\n        <artifactId>javafx-maven-plugin</artifactId>\n        <version>0.0.8</version>\n        <executions>\n          <execution>\n            <!-- Default configuration for running with: mvn clean javafx:run -->\n            <id>default-cli</id>\n            <configuration>\n              <mainClass>com.example.server/com.example.server.HelloApplication</mainClass>\n              <launcher>app</launcher>\n              <jlinkZipName>app</jlinkZipName>\n              <jlinkImageName>app</jlinkImageName>\n              <noManPages>true</noManPages>\n              <stripDebug>true</stripDebug>\n              <noHeaderFiles>true</noHeaderFiles>\n            </configuration>\n          </execution>\n        </executions>\n      </plugin>\n    </plugins>\n  </build>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/pom.xml b/Server/pom.xml
--- a/Server/pom.xml	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/pom.xml	(date 1702255008583)
@@ -39,7 +39,6 @@
       <groupId>org.junit.jupiter</groupId>
       <artifactId>junit-jupiter-api</artifactId>
       <version>${junit.version}</version>
-      <scope>test</scope>
     </dependency>
     <dependency>
       <groupId>org.junit.jupiter</groupId>
@@ -47,6 +46,11 @@
       <version>${junit.version}</version>
       <scope>test</scope>
     </dependency>
+      <dependency>
+          <groupId>junit</groupId>
+          <artifactId>junit</artifactId>
+          <version>4.13.2</version>
+      </dependency>
   </dependencies>
 
   <build>
Index: Server/src/main/java/com/server/server/tests/EmailTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/tests/EmailTest.java b/Server/src/main/java/com/server/server/tests/EmailTest.java
new file mode 100644
--- /dev/null	(date 1702255320904)
+++ b/Server/src/main/java/com/server/server/tests/EmailTest.java	(date 1702255320904)
@@ -0,0 +1,44 @@
+package com.server.server.tests;
+
+import com.server.server.models.Email;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+public class EmailTest {
+
+    @Test
+    public void isValidFormat_withValidEmail_returnsTrue() {
+        assertTrue(Email.isValidFormat("test@example.com"));
+    }
+
+    @Test
+    public void isValidFormat_withInvalidEmail_returnsFalse() {
+        assertFalse(Email.isValidFormat("test@.com"));
+    }
+
+    @Test
+    public void isValidFormat_withEmptyString_returnsFalse() {
+        assertFalse(Email.isValidFormat(""));
+    }
+
+    @Test
+    public void isValidFormat_withEmailExceeding64Characters_returnsFalse() {
+        String localPart = new String(new char[65]).replace("\0", "a");
+        assertFalse(Email.isValidFormat(localPart + "@example.com"));
+    }
+
+    @Test
+    public void isValidFormat_withEmailContainingConsecutiveDots_returnsFalse() {
+        assertFalse(Email.isValidFormat("test..test@example.com"));
+    }
+
+    @Test
+    public void isValidFormat_withEmailStartingWithDot_returnsFalse() {
+        assertFalse(Email.isValidFormat(".test@example.com"));
+    }
+
+    @Test
+    public void isValidFormat_withEmailEndingWithDot_returnsFalse() {
+        assertFalse(Email.isValidFormat("test.@example.com"));
+    }
+}
\ No newline at end of file
Index: Server/src/main/java/com/server/server/utils/handleStrategies/RegisterStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.utils.handleStrategies;\n\nimport com.server.server.models.Logger;\nimport com.server.server.models.Packet;\nimport com.server.server.utils.PacketHandlerStrategy;\nimport com.server.server.utils.PacketUtils;\nimport com.server.server.utils.specificHandlers.RegisterHandler;\n\nimport java.io.ObjectOutputStream;\n\npublic class RegisterStrategy implements PacketHandlerStrategy {\n    @Override\n    public void handlePacket(Packet packet, ObjectOutputStream objectOutputStream, Logger logger) {\n        Packet responsePacket;\n        if(packet.getPayload() instanceof String username){\n            logger.log(\"Received register request from : \" + username, \"Register\" );\n            RegisterHandler registerHandler = new RegisterHandler();\n            responsePacket = registerHandler.register(username);\n        } else {\n            logger.log(\"Received register request with invalid Payload type : \" + packet.getPayload().getClass(), \"Error\" );\n            return;\n        }\n\n        if(responsePacket.getOperation().equals(\"successful\")){\n            logger.log(\"Registered user : \" + packet.getPayload(), \"Register\" );\n        } else {\n            logger.log(\"Failed to register user : \" + packet.getPayload(), \"Error\" );\n        }\n        PacketUtils.sendPacket(responsePacket, objectOutputStream);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/utils/handleStrategies/RegisterStrategy.java b/Server/src/main/java/com/server/server/utils/handleStrategies/RegisterStrategy.java
--- a/Server/src/main/java/com/server/server/utils/handleStrategies/RegisterStrategy.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/utils/handleStrategies/RegisterStrategy.java	(date 1702256527385)
@@ -8,7 +8,21 @@
 
 import java.io.ObjectOutputStream;
 
+/**
+ * Strategy for handling register requests.
+ * Implements the PacketHandlerStrategy interface.
+ */
 public class RegisterStrategy implements PacketHandlerStrategy {
+
+    /**
+     * Method to handle a register request packet.
+     * If the payload of the packet is a String, it logs the request and calls the register method of RegisterHandler.
+     * If the payload is not a String, it logs an error and returns.
+     * After handling the packet, it sends a response packet indicating the result of the operation.
+     * @param packet The packet to handle
+     * @param objectOutputStream The ObjectOutputStream to write the response to
+     * @param logger The logger to log events
+     */
     @Override
     public void handlePacket(Packet packet, ObjectOutputStream objectOutputStream, Logger logger) {
         Packet responsePacket;
@@ -28,4 +42,4 @@
         }
         PacketUtils.sendPacket(responsePacket, objectOutputStream);
     }
-}
+}
\ No newline at end of file
Index: .idea/Prog3_Project.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<module type=\"JAVA_MODULE\" version=\"4\">\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n    <exclude-output />\n    <content url=\"file://$MODULE_DIR$\" />\n    <orderEntry type=\"inheritedJdk\" />\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n  </component>\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/Prog3_Project.iml b/.idea/Prog3_Project.iml
--- a/.idea/Prog3_Project.iml	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/.idea/Prog3_Project.iml	(date 1702254691647)
@@ -1,6 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <module type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
+  <component name="NewModuleRootManager">
+    <output url="file://$MODULE_DIR$/out/production/Prog3_Project" />
+    <output-test url="file://$MODULE_DIR$/out/test/Prog3_Project" />
     <exclude-output />
     <content url="file://$MODULE_DIR$" />
     <orderEntry type="inheritedJdk" />
Index: Server/src/main/java/com/server/server/utils/handleStrategies/LoginStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.utils.handleStrategies;\n\nimport com.server.server.models.Logger;\nimport com.server.server.models.Packet;\nimport com.server.server.utils.specificHandlers.LoginHandler;\nimport com.server.server.utils.PacketHandlerStrategy;\nimport com.server.server.utils.PacketUtils;\n\nimport java.io.ObjectOutputStream;\n\npublic class LoginStrategy implements PacketHandlerStrategy {\n    @Override\n    public void handlePacket(Packet packet, ObjectOutputStream objectOutputStream, Logger logger) {\n        Packet responsePacket;\n        if(packet.getPayload() instanceof String username){\n            logger.log(\"Received login request from : \" + username, \"Login\" );\n            LoginHandler loginHandler = new LoginHandler();\n            responsePacket = loginHandler.login(username);\n        } else {\n            logger.log(\"Received login request with invalid Payload type : \" + packet.getPayload().getClass(), \"Error\" );\n            return;\n        }\n\n        if(responsePacket.getOperation().equals(\"successful\")){\n            PacketUtils.sendPacket(responsePacket, objectOutputStream);\n            logger.log(\"Logged in user : \" + packet.getPayload(), \"Login\" );\n        } else {\n            PacketUtils.sendPacket(responsePacket, objectOutputStream);\n            logger.log(\"Failed to login user : \" + packet.getPayload(), \"Error\" );\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/utils/handleStrategies/LoginStrategy.java b/Server/src/main/java/com/server/server/utils/handleStrategies/LoginStrategy.java
--- a/Server/src/main/java/com/server/server/utils/handleStrategies/LoginStrategy.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/utils/handleStrategies/LoginStrategy.java	(date 1702256836121)
@@ -8,7 +8,21 @@
 
 import java.io.ObjectOutputStream;
 
+/**
+ * This class implements the PacketHandlerStrategy interface and provides a specific strategy to handle login packets.
+ */
 public class LoginStrategy implements PacketHandlerStrategy {
+
+    /**
+     * This method handles the incoming packet and performs the necessary operations based on the packet's payload.
+     * If the payload is a string, it logs the login request, creates a new LoginHandler, and calls its login method.
+     * If the payload is not a string, it logs an error message and returns without doing anything.
+     * After handling the packet, it sends a response packet back to the sender.
+     *
+     * @param packet The incoming packet to be handled.
+     * @param objectOutputStream The ObjectOutputStream to send the response packet.
+     * @param logger The logger to log the operations.
+     */
     @Override
     public void handlePacket(Packet packet, ObjectOutputStream objectOutputStream, Logger logger) {
         Packet responsePacket;
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"62e09469-553b-4e2a-b21e-c9a9d5c656af\" name=\"Changes\" comment=\"fixed the creation of accounts in Register Handler\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/Client/src/main/java/com/client/client/controllers/ClientController.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Client/src/main/java/com/client/client/controllers/ClientController.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/Client/src/main/java/com/client/client/controllers/loginController.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Client/src/main/java/com/client/client/controllers/loginController.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/Client/src/main/java/com/client/client/models/PacketHandler.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Client/src/main/java/com/client/client/models/PacketHandler.java\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"FxmlFile\" />\n        <option value=\"CSS File\" />\n        <option value=\"Class\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"communication_fixing\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"GitHubPullRequestSearchHistory\">{\n  &quot;history&quot;: [\n    {\n      &quot;state&quot;: &quot;OPEN&quot;\n    }\n  ],\n  &quot;lastFilter&quot;: {\n    &quot;state&quot;: &quot;OPEN&quot;\n  }\n}</component>\n  <component name=\"GithubPullRequestsUISettings\">\n    <option name=\"selectedUrlAndAccountId\">\n      <UrlAndAccount>\n        <option name=\"accountId\" value=\"ce91cf13-0503-44c1-90cf-7beb791f4bdf\" />\n        <option name=\"url\" value=\"https://github.com/00-uno-00/Prog3_Project.git\" />\n      </UrlAndAccount>\n    </option>\n  </component>\n  <component name=\"HighlightingSettingsPerFile\">\n    <setting file=\"file://$PROJECT_DIR$/Server/src/main/java/com/server/server/models/ServerModel.java\" root0=\"FORCE_HIGHLIGHTING\" />\n  </component>\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"MavenImportPreferences\">\n    <option name=\"generalSettings\">\n      <MavenGeneralSettings>\n        <option name=\"mavenHome\" value=\"Use Maven wrapper\" />\n      </MavenGeneralSettings>\n    </option>\n  </component>\n  <component name=\"ProblemsViewState\">\n    <option name=\"selectedTabId\" value=\"CurrentFile\" />\n  </component>\n  <component name=\"ProjectColorInfo\">{\n  &quot;associatedIndex&quot;: 6\n}</component>\n  <component name=\"ProjectId\" id=\"2YaVWRXbT9pFFDXPaL5wYQzapHe\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\"><![CDATA[{\n  \"keyToString\": {\n    \"ASKED_ADD_EXTERNAL_FILES\": \"true\",\n    \"ASKED_SHARE_PROJECT_CONFIGURATION_FILES\": \"true\",\n    \"Application.ClientApplication.executor\": \"Run\",\n    \"Application.ServerApplication.executor\": \"Run\",\n    \"Downloaded.Files.Path.Enabled\": \"false\",\n    \"Repository.Attach.Annotations\": \"false\",\n    \"Repository.Attach.JavaDocs\": \"false\",\n    \"Repository.Attach.Sources\": \"false\",\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\n    \"WebServerToolWindowFactoryState\": \"false\",\n    \"git-widget-placeholder\": \"main\",\n    \"ignore.virus.scanning.warn.message\": \"true\",\n    \"jdk.selected.JAVA_MODULE\": \"18\",\n    \"kotlin-language-version-configured\": \"true\",\n    \"last.edited.regexp\": \"Sample.Text@mymail.com\",\n    \"last_opened_file_path\": \"/home/davide/Desktop/PROGIII/Prog3_Project/Client/src/main/resources/com/client/client/icons\",\n    \"list.type.of.created.stylesheet\": \"CSS\",\n    \"node.js.detected.package.eslint\": \"true\",\n    \"node.js.detected.package.tslint\": \"true\",\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\n    \"node.js.selected.package.tslint\": \"(autodetect)\",\n    \"nodejs_package_manager_path\": \"npm\",\n    \"project.structure.last.edited\": \"Global Libraries\",\n    \"project.structure.proportion\": \"0.15\",\n    \"project.structure.side.proportion\": \"0.2\",\n    \"settings.editor.selected.configurable\": \"preferences.pluginManager\",\n    \"vue.rearranger.settings.migration\": \"true\"\n  },\n  \"keyToStringList\": {\n    \"com.intellij.ide.scratch.ScratchImplUtil$2/New Scratch File\": [\n      \"PLAIN_TEXT\"\n    ]\n  }\n}]]></component>\n  <component name=\"RecentsManager\">\n    <key name=\"CreateClassDialog.RecentsKey\">\n      <recent name=\"com.server.server.utils\" />\n    </key>\n    <key name=\"CopyFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/Client/src/main/resources/com/client/client/icons\" />\n    </key>\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/Server/src/main/resources/com/server/server\" />\n      <recent name=\"$PROJECT_DIR$/Server/target/classes/com/server/server/models\" />\n      <recent name=\"$PROJECT_DIR$/Server/target/classes/com/server/server\" />\n      <recent name=\"E:\\UNI\\Prog3_Project\" />\n      <recent name=\"$PROJECT_DIR$\" />\n    </key>\n  </component>\n  <component name=\"RunManager\" selected=\"Application.ClientApplication\">\n    <configuration name=\"ServerApplication\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\n      <option name=\"MAIN_CLASS_NAME\" value=\"com.server.server.ServerApplication\" />\n      <module name=\"Server\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"com.server.server.models.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <list>\n      <item itemvalue=\"Application.ServerApplication\" />\n      <item itemvalue=\"Application.ClientApplication\" />\n    </list>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"Application.ServerApplication\" />\n        <item itemvalue=\"Application.ServerApplication\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SharedIndexes\">\n    <attachedChunks>\n      <set>\n        <option value=\"jdk-18.0.2-corretto-18.0.2-3183f394aec4-0dc1e537\" />\n      </set>\n    </attachedChunks>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"62e09469-553b-4e2a-b21e-c9a9d5c656af\" name=\"Changes\" comment=\"\" />\n      <created>1700763708801</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1700763708801</updated>\n      <workItem from=\"1700763709937\" duration=\"1718000\" />\n      <workItem from=\"1700766518257\" duration=\"1043000\" />\n      <workItem from=\"1700831554737\" duration=\"2955000\" />\n      <workItem from=\"1700922270211\" duration=\"8382000\" />\n      <workItem from=\"1700998538093\" duration=\"2522000\" />\n      <workItem from=\"1701005019552\" duration=\"6845000\" />\n      <workItem from=\"1701020047774\" duration=\"152000\" />\n      <workItem from=\"1701020207394\" duration=\"6391000\" />\n      <workItem from=\"1701084609937\" duration=\"17870000\" />\n      <workItem from=\"1701168451806\" duration=\"301000\" />\n      <workItem from=\"1701181609905\" duration=\"3623000\" />\n      <workItem from=\"1701251303262\" duration=\"3746000\" />\n      <workItem from=\"1701255640013\" duration=\"2690000\" />\n      <workItem from=\"1701276171524\" duration=\"6322000\" />\n      <workItem from=\"1701340434216\" duration=\"4772000\" />\n      <workItem from=\"1701354112081\" duration=\"4908000\" />\n      <workItem from=\"1701369416807\" duration=\"11716000\" />\n      <workItem from=\"1701422009545\" duration=\"2777000\" />\n      <workItem from=\"1701428280952\" duration=\"3707000\" />\n      <workItem from=\"1701454608982\" duration=\"109000\" />\n      <workItem from=\"1701454741833\" duration=\"17813000\" />\n      <workItem from=\"1701562957455\" duration=\"1065000\" />\n      <workItem from=\"1701603240636\" duration=\"2921000\" />\n      <workItem from=\"1701694477152\" duration=\"7039000\" />\n      <workItem from=\"1701801693489\" duration=\"832000\" />\n      <workItem from=\"1701814924745\" duration=\"4030000\" />\n      <workItem from=\"1701898066131\" duration=\"125000\" />\n      <workItem from=\"1701898355715\" duration=\"455000\" />\n      <workItem from=\"1701898829938\" duration=\"121000\" />\n      <workItem from=\"1701899139333\" duration=\"3932000\" />\n      <workItem from=\"1701962663204\" duration=\"28000\" />\n      <workItem from=\"1702038193604\" duration=\"440000\" />\n      <workItem from=\"1702055307861\" duration=\"3000\" />\n      <workItem from=\"1702057336233\" duration=\"234000\" />\n      <workItem from=\"1702057775456\" duration=\"1662000\" />\n      <workItem from=\"1702060132803\" duration=\"1057000\" />\n      <workItem from=\"1702061271249\" duration=\"3000\" />\n      <workItem from=\"1702061402445\" duration=\"117000\" />\n      <workItem from=\"1702141532472\" duration=\"3901000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"Server branch\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701085730039</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701085730039</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"Server buttons\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701091909252</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701091909252</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"Improved server interface UI and added logging features\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701106955955</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701106955955</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"Improved documentation.\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701107315786</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701107315786</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"Added server shut down on close request.\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701109617339</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701109617339</updated>\n    </task>\n    <task id=\"LOCAL-00006\" summary=\"Email and Packet class\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701115957375</created>\n      <option name=\"number\" value=\"00006\" />\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701115957375</updated>\n    </task>\n    <task id=\"LOCAL-00007\" summary=\"Added protocol idea\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701116200480</created>\n      <option name=\"number\" value=\"00007\" />\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701116200480</updated>\n    </task>\n    <task id=\"LOCAL-00008\" summary=\"Added protocol idea and email and packet class\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701126958542</created>\n      <option name=\"number\" value=\"00008\" />\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701126958542</updated>\n    </task>\n    <task id=\"LOCAL-00009\" summary=\"Reformatting and better folders\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701249483058</created>\n      <option name=\"number\" value=\"00009\" />\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701249483058</updated>\n    </task>\n    <task id=\"LOCAL-00010\" summary=\"Added ID variable and file\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701259009943</created>\n      <option name=\"number\" value=\"00010\" />\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701259009943</updated>\n    </task>\n    <task id=\"LOCAL-00011\" summary=\"Added logger singleton and model split\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701282484617</created>\n      <option name=\"number\" value=\"00011\" />\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701282484617</updated>\n    </task>\n    <task id=\"LOCAL-00012\" summary=\"Fixed unresponsive logging and minor changes\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701345281741</created>\n      <option name=\"number\" value=\"00012\" />\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701345281741</updated>\n    </task>\n    <task id=\"LOCAL-00013\" summary=\"Added Packet handler logic and log type\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701359007024</created>\n      <option name=\"number\" value=\"00013\" />\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701359007024</updated>\n    </task>\n    <task id=\"LOCAL-00014\" summary=\"Implemented list sync scroll and readability improvements\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701386647686</created>\n      <option name=\"number\" value=\"00014\" />\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701386647686</updated>\n    </task>\n    <task id=\"LOCAL-00015\" summary=\"Added email handling logic and minor fixes\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701474878939</created>\n      <option name=\"number\" value=\"00015\" />\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701474878939</updated>\n    </task>\n    <task id=\"LOCAL-00016\" summary=\"Added handlers for specific packets and send logic\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701564013265</created>\n      <option name=\"number\" value=\"00016\" />\n      <option name=\"presentableId\" value=\"LOCAL-00016\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701564013265</updated>\n    </task>\n    <task id=\"LOCAL-00017\" summary=\"Useful renames\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701604463272</created>\n      <option name=\"number\" value=\"00017\" />\n      <option name=\"presentableId\" value=\"LOCAL-00017\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701604463272</updated>\n    </task>\n    <task id=\"LOCAL-00018\" summary=\"Useful renames+better strategies\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701819037941</created>\n      <option name=\"number\" value=\"00018\" />\n      <option name=\"presentableId\" value=\"LOCAL-00018\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701819037941</updated>\n    </task>\n    <task id=\"LOCAL-00019\" summary=\"Useful renames and logger directory check\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701946497414</created>\n      <option name=\"number\" value=\"00019\" />\n      <option name=\"presentableId\" value=\"LOCAL-00019\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701946497414</updated>\n    </task>\n    <task id=\"LOCAL-00020\" summary=\"Implemented refresh handler and strategy server-side\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701949132118</created>\n      <option name=\"number\" value=\"00020\" />\n      <option name=\"presentableId\" value=\"LOCAL-00020\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701949132118</updated>\n    </task>\n    <task id=\"LOCAL-00021\" summary=\"Verbose logging server side and run configs\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1702039641665</created>\n      <option name=\"number\" value=\"00021\" />\n      <option name=\"presentableId\" value=\"LOCAL-00021\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1702039641665</updated>\n    </task>\n    <task id=\"LOCAL-00022\" summary=\"Added client icon\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1702053746405</created>\n      <option name=\"number\" value=\"00022\" />\n      <option name=\"presentableId\" value=\"LOCAL-00022\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1702053746405</updated>\n    </task>\n    <task id=\"LOCAL-00023\" summary=\"now &quot;client&quot; is a valid sender\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1702057561627</created>\n      <option name=\"number\" value=\"00023\" />\n      <option name=\"presentableId\" value=\"LOCAL-00023\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1702057561627</updated>\n    </task>\n    <task id=\"LOCAL-00024\" summary=\"is valid format is now working\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1702058766587</created>\n      <option name=\"number\" value=\"00024\" />\n      <option name=\"presentableId\" value=\"LOCAL-00024\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1702058766587</updated>\n    </task>\n    <task id=\"LOCAL-00025\" summary=\"fixed the creation of accounts in Register Handler\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1702061060963</created>\n      <option name=\"number\" value=\"00025\" />\n      <option name=\"presentableId\" value=\"LOCAL-00025\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1702061060963</updated>\n    </task>\n    <task id=\"LOCAL-00026\" summary=\"fixed the creation of accounts in Register Handler\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1702061075892</created>\n      <option name=\"number\" value=\"00026\" />\n      <option name=\"presentableId\" value=\"LOCAL-00026\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1702061075892</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"27\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"RECENT_FILTERS\">\n      <map>\n        <entry key=\"Branch\">\n          <value>\n            <list>\n              <RecentGroup>\n                <option name=\"FILTER_VALUES\">\n                  <option value=\"origin/server\" />\n                </option>\n              </RecentGroup>\n              <RecentGroup>\n                <option name=\"FILTER_VALUES\">\n                  <option value=\"main\" />\n                </option>\n              </RecentGroup>\n            </list>\n          </value>\n        </entry>\n      </map>\n    </option>\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State>\n              <option name=\"FILTERS\">\n                <map>\n                  <entry key=\"branch\">\n                    <value>\n                      <list>\n                        <option value=\"origin/server\" />\n                      </list>\n                    </value>\n                  </entry>\n                </map>\n              </option>\n            </State>\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"Server branch\" />\n    <MESSAGE value=\"Server buttons\" />\n    <MESSAGE value=\"Improved server interface UI and added logging features\" />\n    <MESSAGE value=\"Improved documentation.\" />\n    <MESSAGE value=\"Added server shut down on close request.\" />\n    <MESSAGE value=\"Email and Packet class\" />\n    <MESSAGE value=\"Added protocol idea\" />\n    <MESSAGE value=\"Added protocol idea and email and packet class\" />\n    <MESSAGE value=\"Reformatting and better folders\" />\n    <MESSAGE value=\"Added ID variable and file\" />\n    <MESSAGE value=\"Added logger singleton and model split\" />\n    <MESSAGE value=\"Fixed unresponsive logging and minor changes\" />\n    <MESSAGE value=\"Added Packet handler logic and log type\" />\n    <MESSAGE value=\"Implemented list sync scroll and readability improvements\" />\n    <MESSAGE value=\"Added email handling logic and minor fixes\" />\n    <MESSAGE value=\"Added handlers for specific packets and send logic\" />\n    <MESSAGE value=\"Useful renames\" />\n    <MESSAGE value=\"Useful renames+better strategies\" />\n    <MESSAGE value=\"Useful renames and logger directory check\" />\n    <MESSAGE value=\"Implemented refresh handler and strategy server-side\" />\n    <MESSAGE value=\"Verbose logging server side and run configs\" />\n    <MESSAGE value=\"Added client icon\" />\n    <MESSAGE value=\"now &quot;client&quot; is a valid sender\" />\n    <MESSAGE value=\"is valid format is now working\" />\n    <MESSAGE value=\"fixed the creation of accounts in Register Handler\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"fixed the creation of accounts in Register Handler\" />\n  </component>\n  <component name=\"XDebuggerManager\">\n    <breakpoint-manager>\n      <breakpoints>\n        <line-breakpoint enabled=\"true\" type=\"java-method\">\n          <url>file://$PROJECT_DIR$/Client/src/main/java/com/client/client/models/CommsHandler.java</url>\n          <line>48</line>\n          <properties class=\"com.client.client.models.CommsHandler\" method=\"register\">\n            <option name=\"EMULATED\" value=\"true\" />\n            <option name=\"WATCH_EXIT\" value=\"false\" />\n          </properties>\n          <option name=\"timeStamp\" value=\"8\" />\n        </line-breakpoint>\n        <line-breakpoint enabled=\"true\" type=\"java-method\">\n          <url>file://$PROJECT_DIR$/Client/src/main/java/com/client/client/controllers/loginController.java</url>\n          <line>83</line>\n          <properties class=\"com.client.client.controllers.loginController\" method=\"loadClient\">\n            <option name=\"EMULATED\" value=\"true\" />\n            <option name=\"WATCH_EXIT\" value=\"false\" />\n          </properties>\n          <option name=\"timeStamp\" value=\"26\" />\n        </line-breakpoint>\n        <line-breakpoint enabled=\"true\" type=\"java-method\">\n          <url>file://$PROJECT_DIR$/Client/src/main/java/com/client/client/models/CommsHandler.java</url>\n          <line>35</line>\n          <properties class=\"com.client.client.models.CommsHandler\" method=\"login\">\n            <option name=\"EMULATED\" value=\"true\" />\n            <option name=\"WATCH_EXIT\" value=\"false\" />\n          </properties>\n          <option name=\"timeStamp\" value=\"27\" />\n        </line-breakpoint>\n      </breakpoints>\n    </breakpoint-manager>\n    <watches-manager>\n      <configuration name=\"Application\">\n        <watch expression=\"contactsList.dirtyChildren\" />\n      </configuration>\n    </watches-manager>\n  </component>\n  <component name=\"XSLT-Support.FileAssociations.UIState\">\n    <expand />\n    <select />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/.idea/workspace.xml	(date 1702256904646)
@@ -4,11 +4,31 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="62e09469-553b-4e2a-b21e-c9a9d5c656af" name="Changes" comment="fixed the creation of accounts in Register Handler">
+    <list default="true" id="62e09469-553b-4e2a-b21e-c9a9d5c656af" name="Changes" comment="A bit of mess to make the login work">
+      <change afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/tests/EmailTest.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/Prog3_Project.iml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/Prog3_Project.iml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Client/src/main/java/com/client/client/controllers/ClientController.java" beforeDir="false" afterPath="$PROJECT_DIR$/Client/src/main/java/com/client/client/controllers/ClientController.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Client/src/main/java/com/client/client/controllers/loginController.java" beforeDir="false" afterPath="$PROJECT_DIR$/Client/src/main/java/com/client/client/controllers/loginController.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Client/src/main/java/com/client/client/models/PacketHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/Client/src/main/java/com/client/client/models/PacketHandler.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/pom.xml" beforeDir="false" afterPath="$PROJECT_DIR$/Server/pom.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/controllers/ServerController.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/controllers/ServerController.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/models/ConnectionHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/models/ConnectionHandler.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/models/Email.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/models/Email.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/models/Logger.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/models/Logger.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/models/PacketHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/models/PacketHandler.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/models/ServerModel.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/models/ServerModel.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/AccountUtils.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/AccountUtils.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/PacketHandlerStrategy.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/PacketHandlerStrategy.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/PacketUtils.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/PacketUtils.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/handleStrategies/DeleteStrategy.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/handleStrategies/DeleteStrategy.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/handleStrategies/EmailStrategy.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/handleStrategies/EmailStrategy.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/handleStrategies/LoginStrategy.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/handleStrategies/LoginStrategy.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/handleStrategies/RefreshStrategy.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/handleStrategies/RefreshStrategy.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/handleStrategies/RegisterStrategy.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/handleStrategies/RegisterStrategy.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/specificHandlers/DeleteHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/specificHandlers/DeleteHandler.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/specificHandlers/EmailHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/specificHandlers/EmailHandler.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/specificHandlers/LoginHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/specificHandlers/LoginHandler.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/specificHandlers/RefreshHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/specificHandlers/RefreshHandler.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/specificHandlers/RegisterHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/com/server/server/utils/specificHandlers/RegisterHandler.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Server/src/main/java/module-info.java" beforeDir="false" afterPath="$PROJECT_DIR$/Server/src/main/java/module-info.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -52,6 +72,11 @@
   </component>
   <component name="HighlightingSettingsPerFile">
     <setting file="file://$PROJECT_DIR$/Server/src/main/java/com/server/server/models/ServerModel.java" root0="FORCE_HIGHLIGHTING" />
+  </component>
+  <component name="JavaAutoRunManager">
+    <enabled-run-configurations>
+      <run-configuration type="JUnit" name="EmailTest" />
+    </enabled-run-configurations>
   </component>
   <component name="MarkdownSettingsMigration">
     <option name="stateVersion" value="1" />
@@ -82,6 +107,8 @@
     "Application.ClientApplication.executor": "Run",
     "Application.ServerApplication.executor": "Run",
     "Downloaded.Files.Path.Enabled": "false",
+    "JUnit.EmailTest.executor": "Run",
+    "JUnit.EmailTest.isValidFormat_withInvalidEmail_returnsFalse.executor": "Run",
     "Repository.Attach.Annotations": "false",
     "Repository.Attach.JavaDocs": "false",
     "Repository.Attach.Sources": "false",
@@ -100,7 +127,7 @@
     "node.js.selected.package.eslint": "(autodetect)",
     "node.js.selected.package.tslint": "(autodetect)",
     "nodejs_package_manager_path": "npm",
-    "project.structure.last.edited": "Global Libraries",
+    "project.structure.last.edited": "Modules",
     "project.structure.proportion": "0.15",
     "project.structure.side.proportion": "0.2",
     "settings.editor.selected.configurable": "preferences.pluginManager",
@@ -205,7 +232,10 @@
       <workItem from="1702060132803" duration="1057000" />
       <workItem from="1702061271249" duration="3000" />
       <workItem from="1702061402445" duration="117000" />
-      <workItem from="1702141532472" duration="3901000" />
+      <workItem from="1702141532472" duration="6969000" />
+      <workItem from="1702230674459" duration="756000" />
+      <workItem from="1702254209151" duration="529000" />
+      <workItem from="1702254765437" duration="2139000" />
     </task>
     <task id="LOCAL-00001" summary="Server branch">
       <option name="closed" value="true" />
@@ -415,7 +445,15 @@
       <option name="project" value="LOCAL" />
       <updated>1702061075892</updated>
     </task>
-    <option name="localTasksCounter" value="27" />
+    <task id="LOCAL-00027" summary="A bit of mess to make the login work">
+      <option name="closed" value="true" />
+      <created>1702145773681</created>
+      <option name="number" value="00027" />
+      <option name="presentableId" value="LOCAL-00027" />
+      <option name="project" value="LOCAL" />
+      <updated>1702145773681</updated>
+    </task>
+    <option name="localTasksCounter" value="28" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -465,7 +503,6 @@
     </option>
   </component>
   <component name="VcsManagerConfiguration">
-    <MESSAGE value="Server branch" />
     <MESSAGE value="Server buttons" />
     <MESSAGE value="Improved server interface UI and added logging features" />
     <MESSAGE value="Improved documentation." />
@@ -490,14 +527,15 @@
     <MESSAGE value="now &quot;client&quot; is a valid sender" />
     <MESSAGE value="is valid format is now working" />
     <MESSAGE value="fixed the creation of accounts in Register Handler" />
-    <option name="LAST_COMMIT_MESSAGE" value="fixed the creation of accounts in Register Handler" />
+    <MESSAGE value="A bit of mess to make the login work" />
+    <option name="LAST_COMMIT_MESSAGE" value="A bit of mess to make the login work" />
   </component>
   <component name="XDebuggerManager">
     <breakpoint-manager>
       <breakpoints>
         <line-breakpoint enabled="true" type="java-method">
           <url>file://$PROJECT_DIR$/Client/src/main/java/com/client/client/models/CommsHandler.java</url>
-          <line>48</line>
+          <line>49</line>
           <properties class="com.client.client.models.CommsHandler" method="register">
             <option name="EMULATED" value="true" />
             <option name="WATCH_EXIT" value="false" />
@@ -506,21 +544,12 @@
         </line-breakpoint>
         <line-breakpoint enabled="true" type="java-method">
           <url>file://$PROJECT_DIR$/Client/src/main/java/com/client/client/controllers/loginController.java</url>
-          <line>83</line>
+          <line>88</line>
           <properties class="com.client.client.controllers.loginController" method="loadClient">
             <option name="EMULATED" value="true" />
             <option name="WATCH_EXIT" value="false" />
           </properties>
           <option name="timeStamp" value="26" />
-        </line-breakpoint>
-        <line-breakpoint enabled="true" type="java-method">
-          <url>file://$PROJECT_DIR$/Client/src/main/java/com/client/client/models/CommsHandler.java</url>
-          <line>35</line>
-          <properties class="com.client.client.models.CommsHandler" method="login">
-            <option name="EMULATED" value="true" />
-            <option name="WATCH_EXIT" value="false" />
-          </properties>
-          <option name="timeStamp" value="27" />
         </line-breakpoint>
       </breakpoints>
     </breakpoint-manager>
Index: Server/src/main/java/com/server/server/utils/handleStrategies/RefreshStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.utils.handleStrategies;\n\nimport com.server.server.models.Logger;\nimport com.server.server.models.Packet;\nimport com.server.server.utils.PacketHandlerStrategy;\nimport com.server.server.utils.PacketUtils;\nimport com.server.server.utils.specificHandlers.RefreshHandler;\n\nimport java.io.ObjectOutputStream;\nimport java.util.List;\n\npublic class RefreshStrategy implements PacketHandlerStrategy {\n    @Override\n    public void handlePacket(Packet packet, ObjectOutputStream objectOutputStream, Logger logger) {\n        Packet responsePacket;\n        String username = packet.getSender();\n        if(packet.getPayload() instanceof List){\n            logger.log(\"Received refresh request from : \" + username, \"Refresh\" );\n            RefreshHandler refreshHandler = new RefreshHandler();\n            responsePacket = refreshHandler.refresh(username, (List<Integer>) packet.getPayload());\n            //TODO try to make this cast safer\n        } else {\n            logger.log(\"Received refresh request with invalid Payload type : \" + packet.getPayload().getClass(), \"Refresh\" );\n            return;\n        }\n        logger.log(\"Sending refresh response to : \" + username, \"Refresh\" );\n        if(responsePacket.getOperation().equals(\"successful\")){\n            logger.log(\"Successfully sent emails to : \" + username, \"Refresh\" );\n        } else {\n            logger.log(\"Failed to send emails to : \" + username, \"Error\" );\n        }\n        PacketUtils.sendPacket(responsePacket, objectOutputStream);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/utils/handleStrategies/RefreshStrategy.java b/Server/src/main/java/com/server/server/utils/handleStrategies/RefreshStrategy.java
--- a/Server/src/main/java/com/server/server/utils/handleStrategies/RefreshStrategy.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/utils/handleStrategies/RefreshStrategy.java	(date 1702256796857)
@@ -9,7 +9,21 @@
 import java.io.ObjectOutputStream;
 import java.util.List;
 
+/**
+ * This class implements the PacketHandlerStrategy interface and provides a specific strategy to handle refresh packets.
+ */
 public class RefreshStrategy implements PacketHandlerStrategy {
+
+    /**
+     * This method handles the incoming packet and performs the necessary operations based on the packet's payload.
+     * If the payload is a list, it logs the refresh request, creates a new RefreshHandler, and calls its refresh method.
+     * If the payload is not a list, it logs an error message and returns without doing anything.
+     * After handling the packet, it sends a response packet back to the sender.
+     *
+     * @param packet The incoming packet to be handled.
+     * @param objectOutputStream The ObjectOutputStream to send the response packet.
+     * @param logger The logger to log the operations.
+     */
     @Override
     public void handlePacket(Packet packet, ObjectOutputStream objectOutputStream, Logger logger) {
         Packet responsePacket;
@@ -18,7 +32,6 @@
             logger.log("Received refresh request from : " + username, "Refresh" );
             RefreshHandler refreshHandler = new RefreshHandler();
             responsePacket = refreshHandler.refresh(username, (List<Integer>) packet.getPayload());
-            //TODO try to make this cast safer
         } else {
             logger.log("Received refresh request with invalid Payload type : " + packet.getPayload().getClass(), "Refresh" );
             return;
@@ -31,4 +44,4 @@
         }
         PacketUtils.sendPacket(responsePacket, objectOutputStream);
     }
-}
+}
\ No newline at end of file
Index: Server/src/main/java/com/server/server/utils/specificHandlers/RefreshHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.utils.specificHandlers;\n\nimport com.server.server.models.Email;\nimport com.server.server.models.Packet;\nimport com.server.server.utils.AccountUtils;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class RefreshHandler {\n    public Packet refresh(String username, List<Integer> presentIds) {\n        String accountFolder = AccountUtils.getAccountFolder(username);\n        HashMap<Integer, Email> emails;\n        List<Email> emailList;\n        if(AccountUtils.doesAccountExist(accountFolder)){\n            return new Packet(\"failed\", \"Account does not exist\", \"server\");\n        }\n        emails = AccountUtils.retrieveEmails(accountFolder);\n        if(emails.isEmpty()) {\n            return new Packet(\"successful\", new ArrayList<Email>(), \"server\");\n        } else {\n         emailList = new ArrayList<>(emails.values());\n        }\n        List<Email> neededEmails = new ArrayList<>();\n        //foreach email in emails check if it's id is present in presentIds, if not add it to neededEmails\n        if(presentIds.isEmpty()){\n            return new Packet(\"successful\", emailList, \"server\");\n        }\n        for(Email email : emailList){\n            if(!presentIds.contains(email.getId())){\n                neededEmails.add(email);\n            }\n        }\n        return new Packet(\"successful\", neededEmails, \"server\");\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/utils/specificHandlers/RefreshHandler.java b/Server/src/main/java/com/server/server/utils/specificHandlers/RefreshHandler.java
--- a/Server/src/main/java/com/server/server/utils/specificHandlers/RefreshHandler.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/utils/specificHandlers/RefreshHandler.java	(date 1702255877772)
@@ -8,30 +8,55 @@
 import java.util.HashMap;
 import java.util.List;
 
+/**
+ * Handler class for refreshing emails.
+ */
 public class RefreshHandler {
+
+    /**
+     * Refreshes the emails for a given user.
+     * @param username the username of the user
+     * @param presentIds the list of email IDs that the user already has
+     * @return a Packet containing the status of the operation and the list of new emails
+     */
     public Packet refresh(String username, List<Integer> presentIds) {
         String accountFolder = AccountUtils.getAccountFolder(username);
         HashMap<Integer, Email> emails;
         List<Email> emailList;
+
+        // Check if the account exists
         if(AccountUtils.doesAccountExist(accountFolder)){
             return new Packet("failed", "Account does not exist", "server");
         }
+
+        // Retrieve the emails from the account
         emails = AccountUtils.retrieveEmails(accountFolder);
-        if(emails.isEmpty()) {
+
+        // Check if the emails were retrieved successfully
+        if(emails != null && emails.isEmpty()) {
             return new Packet("successful", new ArrayList<Email>(), "server");
-        } else {
-         emailList = new ArrayList<>(emails.values());
+        } else if (emails != null){
+            emailList = new ArrayList<>(emails.values());
+        } else {
+            return new Packet("failed", "Error retrieving emails", "server");
         }
+
         List<Email> neededEmails = new ArrayList<>();
-        //foreach email in emails check if it's id is present in presentIds, if not add it to neededEmails
+
+        // If there are no present IDs, return all emails
         if(presentIds.isEmpty()){
             return new Packet("successful", emailList, "server");
         }
+
+        // Check each email to see if it's ID is in the list of present IDs
+        // If it's not, add it to the list of needed emails
         for(Email email : emailList){
             if(!presentIds.contains(email.getId())){
                 neededEmails.add(email);
             }
         }
+
+        // Return the list of needed emails
         return new Packet("successful", neededEmails, "server");
     }
-}
+}
\ No newline at end of file
Index: Server/src/main/java/module-info.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>module com.example.server {\n    requires javafx.controls;\n    requires javafx.fxml;\n\n    requires org.kordamp.bootstrapfx.core;\n    requires com.google.gson;\n\n    opens com.server.server to javafx.fxml;\n    exports com.server.server;\n    exports com.server.server.models;\n    opens com.server.server.models to javafx.fxml;\n    exports com.server.server.controllers;\n    opens com.server.server.controllers to javafx.fxml;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/module-info.java b/Server/src/main/java/module-info.java
--- a/Server/src/main/java/module-info.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/module-info.java	(date 1702255320892)
@@ -4,6 +4,7 @@
 
     requires org.kordamp.bootstrapfx.core;
     requires com.google.gson;
+    requires junit;
 
     opens com.server.server to javafx.fxml;
     exports com.server.server;
@@ -11,4 +12,6 @@
     opens com.server.server.models to javafx.fxml;
     exports com.server.server.controllers;
     opens com.server.server.controllers to javafx.fxml;
+    exports com.server.server.tests;
+    opens com.server.server.tests to javafx.fxml;
 }
\ No newline at end of file
Index: Server/src/main/java/com/server/server/utils/specificHandlers/RegisterHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.utils.specificHandlers;\n\nimport com.server.server.models.Email;\n\nimport com.server.server.models.Packet;\nimport com.server.server.utils.AccountUtils;\n\npublic class RegisterHandler {\n\n    public Packet register(String username) {\n        Packet responsePacket;\n\n        if (Email.isValidFormat(username)) {\n            responsePacket = new Packet(\"failed\", \"invalid username format\", \"server\");\n            return responsePacket;\n        }\n        String accountFolder = \"Server/src/main/resources/com/server/server/accounts/\" + username;\n        if (!AccountUtils.isAlreadyTaken(accountFolder)) {\n            responsePacket = new Packet(\"failed\", \"username already taken\", \"server\");\n            return responsePacket;\n        }\n        if(!AccountUtils.createAccountFolder(accountFolder)) {\n            responsePacket = new Packet(\"failed\", \"error creating account folder\", \"server\");\n            return responsePacket;\n        }\n            if(!AccountUtils.initializeAccountFolder(accountFolder)){\n            responsePacket = new Packet(\"failed\", \"error initializing account folder\", \"server\");\n            return responsePacket;\n        }\n        responsePacket = new Packet(\"successful\", \"registered\", \"server\");\n        return responsePacket;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/utils/specificHandlers/RegisterHandler.java b/Server/src/main/java/com/server/server/utils/specificHandlers/RegisterHandler.java
--- a/Server/src/main/java/com/server/server/utils/specificHandlers/RegisterHandler.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/utils/specificHandlers/RegisterHandler.java	(date 1702256376903)
@@ -1,33 +1,50 @@
 package com.server.server.utils.specificHandlers;
 
 import com.server.server.models.Email;
-
 import com.server.server.models.Packet;
 import com.server.server.utils.AccountUtils;
 
+/**
+ * Class responsible for handling registration requests.
+ */
 public class RegisterHandler {
 
+    /**
+     * Method to register a new user.
+     * Validates the username, checks if it's already taken, creates and initializes the account folder.
+     * @param username The username to register
+     * @return a Packet indicating the result of the registration
+     */
     public Packet register(String username) {
         Packet responsePacket;
 
+        // Check if the username is in a valid email format
         if (Email.isValidFormat(username)) {
             responsePacket = new Packet("failed", "invalid username format", "server");
             return responsePacket;
         }
+
+        // Check if the username is already taken
         String accountFolder = "Server/src/main/resources/com/server/server/accounts/" + username;
         if (!AccountUtils.isAlreadyTaken(accountFolder)) {
             responsePacket = new Packet("failed", "username already taken", "server");
             return responsePacket;
         }
+
+        // Create the account folder
         if(!AccountUtils.createAccountFolder(accountFolder)) {
             responsePacket = new Packet("failed", "error creating account folder", "server");
             return responsePacket;
         }
-            if(!AccountUtils.initializeAccountFolder(accountFolder)){
+
+        // Initialize the account folder
+        if(!AccountUtils.initializeAccountFolder(accountFolder)){
             responsePacket = new Packet("failed", "error initializing account folder", "server");
             return responsePacket;
         }
+
+        // If all the above checks pass, the registration is successful
         responsePacket = new Packet("successful", "registered", "server");
         return responsePacket;
     }
-}
+}
\ No newline at end of file
Index: Server/src/main/java/com/server/server/utils/specificHandlers/EmailHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.utils.specificHandlers;\n\nimport com.server.server.models.Email;\nimport com.server.server.models.Packet;\n\nimport com.server.server.utils.AccountUtils;\n\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class EmailHandler {\n    private boolean isValidRecipient(List<String> recipient) {\n        if (recipient == null || recipient.isEmpty()) {\n            return false;\n        }\n        for (String emailAddress : recipient) {\n            // check if the recipient string is equal to\n            // the name of a folder in the directory:\n            //  \"Server/src/main/resources/com/server/server/accounts\"\n            if(AccountUtils.doesAccountExist(emailAddress)){\n                return false;\n            }\n        }\n        return true;\n    }\n    private Packet writeEmail(Email mail, String username) {\n        String accountFolder = \"Server/src/main/resources/com/server/server/accounts/\" + username;\n        HashMap<Integer, Email> emails;\n        emails = AccountUtils.retrieveEmails(accountFolder);\n\n        if (emails != null) {\n            emails.put(mail.getId(), mail);\n        } else {\n            return new Packet(\"failed\", \"Could not retrieve emails\", \"server\");\n        }\n\n        boolean sent = AccountUtils.storeEmails(accountFolder, emails);\n\n        if(sent){\n            return new Packet(\"successful\", \"email written\", \"server\");\n        } else {\n            return new Packet(\"failed\", \"Could not store emails\", \"server\");\n        }\n    }\n\n    private Packet writeEmailToMultiple(Email email, List<String> usernames) {\n        for (String username : usernames) {\n            Packet responsePacket = writeEmail(email, username);\n            if (!responsePacket.getOperation().equals(\"successful\")) {\n                return responsePacket;\n            }\n        }\n        return new Packet(\"successful\", \"emails written\", \"server\");\n    }\n\n    public Packet email(Email mail, List<String> usernames) {\n        if (!isValidRecipient(mail.getRecipient())) {\n            return new Packet(\"failed\", \"invalid recipient\", \"server\");\n        }\n        if(usernames.size()>1){\n            return writeEmailToMultiple(mail, usernames);\n        } else {\n            return writeEmail(mail, usernames.get(0));\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/utils/specificHandlers/EmailHandler.java b/Server/src/main/java/com/server/server/utils/specificHandlers/EmailHandler.java
--- a/Server/src/main/java/com/server/server/utils/specificHandlers/EmailHandler.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/utils/specificHandlers/EmailHandler.java	(date 1702256445744)
@@ -2,13 +2,22 @@
 
 import com.server.server.models.Email;
 import com.server.server.models.Packet;
-
 import com.server.server.utils.AccountUtils;
 
 import java.util.HashMap;
 import java.util.List;
 
+/**
+ * Class responsible for handling email operations.
+ */
 public class EmailHandler {
+
+    /**
+     * Method to validate the recipient of an email.
+     * Checks if the recipient is not null or empty, and if it corresponds to an existing account.
+     * @param recipient The recipient to validate
+     * @return true if the recipient is valid, false otherwise
+     */
     private boolean isValidRecipient(List<String> recipient) {
         if (recipient == null || recipient.isEmpty()) {
             return false;
@@ -23,6 +32,14 @@
         }
         return true;
     }
+
+    /**
+     * Method to write an email to a user's account.
+     * Retrieves the user's emails, adds the new email, and stores the updated list of emails.
+     * @param mail The email to write
+     * @param username The username of the account to write the email to
+     * @return a Packet indicating the result of the operation
+     */
     private Packet writeEmail(Email mail, String username) {
         String accountFolder = "Server/src/main/resources/com/server/server/accounts/" + username;
         HashMap<Integer, Email> emails;
@@ -43,6 +60,13 @@
         }
     }
 
+    /**
+     * Method to write an email to multiple users' accounts.
+     * Calls writeEmail for each username in the list.
+     * @param email The email to write
+     * @param usernames The list of usernames to write the email to
+     * @return a Packet indicating the result of the operation
+     */
     private Packet writeEmailToMultiple(Email email, List<String> usernames) {
         for (String username : usernames) {
             Packet responsePacket = writeEmail(email, username);
@@ -53,6 +77,13 @@
         return new Packet("successful", "emails written", "server");
     }
 
+    /**
+     * Method to handle an email operation.
+     * Validates the recipient, and calls either writeEmail or writeEmailToMultiple depending on the number of recipients.
+     * @param mail The email to handle
+     * @param usernames The list of usernames to send the email to
+     * @return a Packet indicating the result of the operation
+     */
     public Packet email(Email mail, List<String> usernames) {
         if (!isValidRecipient(mail.getRecipient())) {
             return new Packet("failed", "invalid recipient", "server");
Index: Server/src/main/java/com/server/server/utils/specificHandlers/LoginHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.utils.specificHandlers;\n\nimport com.server.server.models.Email;\nimport com.server.server.models.Packet;\nimport com.server.server.utils.AccountUtils;\n\npublic class LoginHandler {\n\n    public Packet login(String username) {\n        Packet responsePacket;\n        if (Email.isValidFormat(username)) {\n            responsePacket = new Packet(\"failed\", \"invalid username format\", \"server\");\n            return responsePacket;\n        }\n        String accountFolder = \"Server/src/main/resources/com/server/server/accounts/\" + username;\n        if (AccountUtils.doesAccountExist(accountFolder)) {\n            responsePacket = new Packet(\"failed\", \"username does not exist\", \"server\");\n            return responsePacket;\n        }\n        if (!AccountUtils.isAccountInitialized(accountFolder)) {\n            responsePacket = new Packet(\"failed\", \"account not initialized\", \"server\");\n            return responsePacket;\n        }\n        responsePacket = new Packet(\"successful\", \"logged in\", \"server\");\n        return responsePacket;\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/utils/specificHandlers/LoginHandler.java b/Server/src/main/java/com/server/server/utils/specificHandlers/LoginHandler.java
--- a/Server/src/main/java/com/server/server/utils/specificHandlers/LoginHandler.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/utils/specificHandlers/LoginHandler.java	(date 1702256405671)
@@ -4,23 +4,40 @@
 import com.server.server.models.Packet;
 import com.server.server.utils.AccountUtils;
 
+/**
+ * Class responsible for handling login requests.
+ */
 public class LoginHandler {
 
+    /**
+     * Method to log in a user.
+     * Validates the username, checks if it exists and if the account is initialized.
+     * @param username The username to log in
+     * @return a Packet indicating the result of the login
+     */
     public Packet login(String username) {
         Packet responsePacket;
+
+        // Check if the username is in a valid email format
         if (Email.isValidFormat(username)) {
             responsePacket = new Packet("failed", "invalid username format", "server");
             return responsePacket;
         }
+
+        // Check if the username exists
         String accountFolder = "Server/src/main/resources/com/server/server/accounts/" + username;
         if (AccountUtils.doesAccountExist(accountFolder)) {
             responsePacket = new Packet("failed", "username does not exist", "server");
             return responsePacket;
         }
+
+        // Check if the account is initialized
         if (!AccountUtils.isAccountInitialized(accountFolder)) {
             responsePacket = new Packet("failed", "account not initialized", "server");
             return responsePacket;
         }
+
+        // If all the above checks pass, the login is successful
         responsePacket = new Packet("successful", "logged in", "server");
         return responsePacket;
     }
Index: Server/src/main/java/com/server/server/utils/specificHandlers/DeleteHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.server.server.utils.specificHandlers;\n\nimport com.server.server.models.Email;\nimport com.server.server.models.Packet;\nimport com.server.server.utils.AccountUtils;\n\nimport java.util.HashMap;\n\npublic class DeleteHandler {\n    public Packet delete(int id, String username) {\n        String accountFolder = AccountUtils.getAccountFolder(username);\n        HashMap<Integer, Email> emails;\n        if(AccountUtils.doesAccountExist(username)){\n            return new Packet(\"failed\", \"Account does not exist\", \"server\");\n        }\n        emails = AccountUtils.retrieveEmails(accountFolder);\n        if(emails==null){\n            return new Packet(\"failed\", \"Could not retrieve emails\", \"server\");\n        }\n        if(emails.containsKey(id)){\n            emails.remove(id);\n            return new Packet(\"successful\", \"email deleted\", \"server\");\n        } else {\n            return new Packet(\"failed\", \"Could not retrieve emails\", \"server\");\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/server/server/utils/specificHandlers/DeleteHandler.java b/Server/src/main/java/com/server/server/utils/specificHandlers/DeleteHandler.java
--- a/Server/src/main/java/com/server/server/utils/specificHandlers/DeleteHandler.java	(revision be12a69cd4f73a47acf1837ebf35220946dc0129)
+++ b/Server/src/main/java/com/server/server/utils/specificHandlers/DeleteHandler.java	(date 1702256494652)
@@ -6,17 +6,34 @@
 
 import java.util.HashMap;
 
+/**
+ * Class responsible for handling delete requests.
+ */
 public class DeleteHandler {
+
+    /**
+     * Method to delete an email from a user's account.
+     * Retrieves the user's emails, removes the email with the specified id, and stores the updated list of emails.
+     * @param id The id of the email to delete
+     * @param username The username of the account to delete the email from
+     * @return a Packet indicating the result of the operation
+     */
     public Packet delete(int id, String username) {
         String accountFolder = AccountUtils.getAccountFolder(username);
         HashMap<Integer, Email> emails;
+
+        // Check if the account exists
         if(AccountUtils.doesAccountExist(username)){
             return new Packet("failed", "Account does not exist", "server");
         }
+
+        // Retrieve the emails
         emails = AccountUtils.retrieveEmails(accountFolder);
         if(emails==null){
             return new Packet("failed", "Could not retrieve emails", "server");
         }
+
+        // Check if the email with the specified id exists, and delete it if it does
         if(emails.containsKey(id)){
             emails.remove(id);
             return new Packet("successful", "email deleted", "server");
@@ -24,4 +41,4 @@
             return new Packet("failed", "Could not retrieve emails", "server");
         }
     }
-}
+}
\ No newline at end of file
